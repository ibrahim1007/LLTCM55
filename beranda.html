<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Risk & Reward Calculator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <!-- Pustaka untuk Excel (xlsx) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Pustaka untuk PDF (jsPDF & html2canvas) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- BARU: Tambahkan plugin jsPDF-AutoTable untuk membuat tabel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <style>
        /* Custom styles based on user's provided CSS */
        body { font-family: 'Inter', sans-serif; background-color: #fcfcfc; color: #333; font-size: 0.8125rem; padding: 0; }
        .container-wrapper { background-color: #ffffff; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.03); border-radius: 12px; border: 1px solid #eeeeee; padding: 1.5rem; margin-top: 6rem; /* Increased margin to accommodate larger header */ margin-left: auto; margin-right: auto; width: 100%; max-width: 1536px; }
        .header-global { position: fixed; top: 0; left: 0; right: 0; padding: 1rem 1.5rem; /* Adjusted padding for better mobile view */ background-color: rgba(255, 255, 255, 0.8); /* White and transparent */ backdrop-filter: blur(10px); border-bottom: 1px solid rgba(0, 0, 0, 0.1); display: flex; align-items: center; justify-content: space-between; z-index: 50; color: #333; /* Black text */ }
        .header-section { background-color: rgba(247, 247, 247, 0.8); border-bottom: 1px solid #e8e8e8; padding: 1.75rem 1.5rem; margin-left: -1.5rem; margin-right: -1.5rem; }
        .text-primary { color: #2a2a2a; }
        .input-label { color: #5a5a5a; font-weight: 500; font-size: 0.75rem; }
        .input-field, .select-field { border: 1px solid #e0e0e0; background-color: #ffffff; color: #333; border-radius: 6px; padding: 0.55rem 0.8rem; transition: border-color 0.2s, box-shadow 0.2s; font-size: 0.75rem; }
        .input-field:focus, .select-field:focus { border-color: #bbbbbb; outline: none; box-shadow: 0 0 0 2px rgba(187, 187, 187, 0.2); }
        .input-group-percent span { background-color: #f0f0f0; border: 1px solid #e0e0e0; border-left: none; border-radius: 0 6px 6px 0; color: #5a5a5a; padding: 0.55rem 0.8rem; font-size: 0.75rem; }
        .buy-button, .sell-button { border: 1px solid #e0e0e0; background-color: #f9f9f9; color: #5a5a5a; border-radius: 6px; transition: background-color 0.2s, color 0.2s, border-color 0.2s; font-size: 0.75rem; padding: 0.55rem 0.8rem; }
        .buy-button.active { background-color: #eafaea; color: #28a745; border-color: #c9ecc9; font-weight: 600; }
        .sell-button.active { background-color: #faeaea; color: #dc3545; border-color: #ecc9c9; font-weight: 600; }

        /* --- Perubahan untuk Tombol Aksi (Add, Calculate) --- */
        .action-button { background-color: #222222; color: #ffffff; border: 1px solid #111111; border-radius: 6px; font-weight: 600; padding: 0.6rem 1.1rem; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); font-size: 0.8125rem; }
        .action-button:hover { background-color: #3a3a3a; border-color: #222222; box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15); }
        .action-button:active { box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }
        /* --- End Perubahan Tombol Aksi --- */

        /* New style for the "Tambah Foto" button */
        .light-action-button { background-color: #e0e0e0; color: #222222; border: 1px solid #cccccc; border-radius: 6px; font-weight: 300; padding: 0.4rem 0.8rem; font-size: 0.75rem; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s; box-shadow: 0 1px 3px (0, 0, 0, 0.08); }
        .light-action-button:hover { background-color: #d0d0d0; border-color: #bbbbbb; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        .light-action-button:active { box-shadow: 0 0 2px rgba(0, 0, 0, 0.05); }

        /* New style for the "Hapus Data" button */
        .delete-data-button { background-color: transparent; color: #dc3545; border: none; font-weight: 300; font-size: 0.75rem; padding: 0.25rem 0.5rem; cursor: pointer; transition: color 0.2s; }
        .delete-data-button:hover { color: #c82333; }

        /* New style for the "Unggah Data" and "Unduh Excel" buttons */
        .upload-data-button { background-color: #e0e0e0; color: #222222; border: 1px solid #cccccc; border-radius: 6px; font-weight: 300; font-size: 0.75rem; padding: 0.25rem 0.5rem; cursor: pointer; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08); }
        .upload-data-button:hover { background-color: #d0d0d0; border-color: #bbbbbb; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        .upload-data-button:active { box-shadow: 0 0 2px rgba(0, 0, 0, 0.05); }

        .delete-row-btn { color: #999; transition: color 0.2s; }
        .delete-row-btn:hover { color: #f44336; }
        .results-table { border-collapse: collapse; width: 100%; }
        .results-table th, .results-table td { padding: 6px 8px; text-align: center; border-bottom: 1px solid #f2f2f2; font-size: 0.6rem; font-weight: 300; white-space: nowrap; }
        .results-table th { background-color: #e0e0e0; color: #333; font-weight: 300; text-transform: uppercase; font-size: 0.6rem; text-align: center; position: sticky; top: 0; z-index: 10; }
        .results-table td:nth-child(1), .results-table td:nth-child(2) { text-align: left; }
        .results-table th:nth-child(1), .results-table th:nth-child(2) { text-align: left; }
        .results-table td:nth-child(14) { text-align: center; font-weight: 300; color: #222; font-size: 0.6rem; }
        .results-table tbody tr:last-child td { border-bottom: none; }
        .results-table tbody tr:hover { background-color: #fdfdfd; }
        .positive-value { color: #28a745; font-weight: 500; }
        .negative-value { color: #dc3545; font-weight: 500; }
        .neutral-value { color: #333; }
        .detail-section { background-color: #ffffff; border: 1px solid #e0e0e0; border-radius: 10px; padding: 1.2rem; box-shadow: 0 2px 10px rgba(0,0,0,0.05); font-size: 0.75rem; }
        .detail-section.active { opacity: 1; transform: translateY(0); }
        .detail-label { font-weight: 600; color: #2a2a2a; margin-right: 0.5rem; }
        .detail-value { color: #555; }
        .error-message { background-color: #fdeaea; color: #dc3545; border: 1px solid #f5c6cb; border-radius: 6px; padding: 8px; font-size: 0.75rem; margin-top: 1rem; }
        /* Custom scrollbar for input rows container */
        #inputRowsContainer { max-height: 400px; overflow-y: auto; padding-right: 8px; margin-bottom: 1.5rem; }
        #inputRowsContainer::-webkit-scrollbar { width: 8px; }
        #inputRowsContainer::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 10px; }
        #inputRowsContainer::-webkit-scrollbar-thumb { background: #d0d0d0; border-radius: 10px; }
        #inputRowsContainer::-webkit-scrollbar-thumb:hover { background: #b0b0b0; }
        /* Styles for the table cell containing action buttons in active plans */
        .action-buttons-cell { display: flex; justify-content: center; align-items: center; gap: 0.4rem; }
        /* Styles for the new action buttons in active plans */
        .action-button-small { background-color: #222222; color: white; padding: 0.3rem 0.6rem; border-radius: 4px; font-weight: 500; font-size: 0.6rem; transition: background-color 0.2s, opacity 0.2s; white-space: nowrap; border: 1px solid #111111; }
        .action-button-small:hover { opacity: 0.8; }

        /* Specific font size for main titles */
        h1.text-3xl { font-size: 1.25rem; font-weight: 200; }
        /* Adjusted font size for h2 titles in statistics sections */
        h2.text-lg { font-size: 0.8rem; font-weight: 300; }
        /* New style for modal title */
        #photoUploadModal h3 { font-size: 0.9rem; font-weight: 600; color: #2a2a2a; }
        p.text-sm { font-size: 0.7rem; font-weight: 200; }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .container-wrapper { padding: 1rem; margin-top: 5rem; }
            .header-global { padding: 1rem 1.5rem; }
            .header-global span, .header-global a { font-size: 0.75rem; }
            #currentDateHeader, #currentTimeHeader, #mobileMenuDateTime { font-size: 0.65rem; }
            .header-section { padding: 1.5rem 1rem; margin-left: -1rem; margin-right: -1rem; }
            h1.text-3xl { font-size: 1.1rem; }
            h2.text-lg { font-size: 0.8rem; }
            .input-row { padding: 1rem; }
            .input-label, .input-field, .select-field, .input-group-percent span, .buy-button, .sell-button, .action-button, .results-table th, .results-table td { font-size: 0.75rem; }
            .action-button { padding: 0.5rem 0.8rem; }
            .action-button-small { padding: 0.2rem 0.4rem; font-size: 0.6rem; }
            .grid-cols-1.sm:grid-cols-2.md:grid-cols-3.lg:grid-cols-6 { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
            .top-left-photo-section { flex-direction: column; align-items: center; gap: 0.5rem; padding-left: 0; padding-top: 0; }
            #executedTradingPlansSection > div.flex { flex-direction: column; align-items: flex-start; gap: 0.75rem; }
            #executedTradingPlansSection > div.flex > h2 { margin-bottom: 0; }
            #executedTradingPlansSection > div.flex > div.flex { flex-direction: row; width: 100%; justify-content: flex-start; }
            .photo-gallery-container { width: 100%; max-width: none; }
            .photo-carousel { width: 100%; height: auto; aspect-ratio: 1 / 1; } 
            .photo-slides img { width: 100%; height: 100%; object-fit: cover; }
            #dailyLineChartContainer, #monthlyBarChartContainer, #overallPercentageCumulativeChartContainer, #overallBalanceCumulativeChartContainer, #overallPipsCumulativeChartContainer, #tradeFrequencyChartContainer { padding: 1rem; min-height: 220px; }
            #pieChartContainer { padding: 1rem; min-height: 280px; }
        }

        @media (min-width: 769px) {
            .header-global { padding: 2rem 2.5rem; }
        }

        /* Ensure tables are horizontally scrollable on small screens */
        .overflow-x-auto { overflow-x: auto; }
        /* Styles for download buttons */
        .download-buttons { display: flex; gap: 0.5rem; margin-top: 1rem; justify-content: flex-end; display: none; }
        .download-button { background-color: #222222; color: #ffffff; padding: 0.4rem 0.8rem; border-radius: 6px; font-weight: 500; font-size: 0.75rem; cursor: pointer; border: none; }
        .download-button.pdf { background-color: #222222; }
        .download-button:hover { opacity: 0.9; }
        .download-button:active { transform: translateY(0); }

        /* Styles for photo gallery container */
        .photo-gallery-container { position: relative; display: block; width: 100%; max-width: 400px; margin: 0 auto; }
        .photo-carousel { width: 100%; aspect-ratio: 1 / 1; height: auto; border-radius: 8px; border: 1px solid #cccccc; object-fit: cover; margin: 0 auto; cursor: pointer; overflow: hidden; }
        .photo-slides { display: flex; transition: transform 0.3s ease-in-out; height: 100%; }
        .photo-slides img { width: 100%; height: 100%; object-fit: cover; flex-shrink: 0; }

        /* New styles for the top-left photo and button container */
        .top-left-photo-section { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; margin-bottom: 1.5rem; }

        @media (min-width: 769px) {
            .top-left-photo-section { flex-direction: row; justify-content: center; }
            .photo-gallery-container { max-width: 400px; }
            #executedTradingPlansSection > div.flex { flex-direction: row; justify-content: space-between; }
            #executedTradingPlansPlansSection > div.flex > div.flex { width: auto; }
        }

        /* Added style for executed plans table container to enable vertical scrolling */
        #executedPlansTableContainer { max-height: 300px; overflow-y: auto; border-radius: 0.5rem; border: 1px solid #e0e0e0; }
        #executedPlansTableContainer::-webkit-scrollbar { width: 8px; }
        #executedPlansTableContainer::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 10px; }
        #executedPlansTableContainer::-webkit-scrollbar-thumb { background: #d0d0d0; border-radius: 10px; }
        #executedPlansTableContainer::-webkit-scrollbar-thumb:hover { background: #b0b0b0; }

        /* --- PERBAIKAN: Style baru untuk kontainer tabel ringkasan dengan scroll vertikal --- */
        .summary-table-container {
            max-height: 320px; /* Perkiraan tinggi untuk 12 baris */
            overflow-y: auto;
            border-radius: 0.5rem;
            border: 1px solid #e0e0e0;
        }
        .summary-table-container::-webkit-scrollbar { width: 8px; }
        .summary-table-container::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 10px; }
        .summary-table-container::-webkit-scrollbar-thumb { background: #d0d0d0; border-radius: 10px; }
        .summary-table-container::-webkit-scrollbar-thumb:hover { background: #b0b0b0; }
        /* --- AKHIR PERBAIKAN --- */

        /* --- Animasi Scroll (Fade-in-up) --- */
        .scroll-animate-section { opacity: 0; transform: translateY(50px); transition: opacity 0.6s ease-out, transform 0.6s ease-out; }
        .scroll-animate-section.scrolled-into-view { opacity: 1; transform: translateY(0); }

        /* Adjusted Pie Chart Container for a balanced size */
        #pieChartContainer { min-height: 220px; max-width: 350px; margin: 0 auto; }

        /* Ensure canvas itself is responsive within its container */
        #assetSuccessPieChart { width: 100% !important; height: auto !important; }

        /* Styling for the new informational text section */
        .info-section { background-color: #ffffff; border: 1px solid #e0e0e0; border-radius: 12px; padding: 2rem; margin-top: 2rem; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.03); }
        .info-section h2 { font-size: 1.25rem; font-weight: 500; color: #2a2a2a; margin-bottom: 1rem; border-bottom: 1px solid #e8e8e8; padding-bottom: 0.5rem; }
        .info-section h3 { font-size: 1rem; font-weight: 600; color: #333; margin-top: 1.5rem; margin-bottom: 0.75rem; }
        .info-section p { font-size: 0.875rem; font-weight: 300; color: #555; line-height: 1.6; margin-bottom: 1rem; }
        .info-section ul { list-style-type: disc; margin-left: 1.5rem; margin-bottom: 1rem; }
        .info-section ul li { font-size: 0.875rem; font-weight: 300; color: #555; margin-bottom: 0.5rem; }
        .info-section strong { font-weight: 500; color: #333; }
        .info-section .list-circle { list-style-type: circle; }

        /* New style for numbers in Overall Summary Statistics */
        #overallSummaryStatisticsSection p.text-base { font-weight: 300; color: #222222; }
        #overallSummaryStatisticsSection p.text-base.negative-summary-value { color: #dc3545; }

        /* New style for numbers in Risk and Reward Statistics */
        #riskRewardStatisticsSection p.text-base { font-weight: 300; color: #222222; }
        #riskRewardStatisticsSection p.text-lg { font-weight: 300; color: #222222; }

        /* Modal specific styles */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 100; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal.show { opacity: 1; visibility: visible; }
        .modal-content { background-color: #ffffff; padding: 2rem; border-radius: 12px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); width: 90%; max-width: 500px; position: relative; transform: translateY(-20px); transition: transform 0.3s ease; }
        .modal.show .modal-content { transform: translateY(0); }
        .modal-close-button { position: absolute; top: 1rem; right: 1rem; background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #999; }
        .modal-close-button:hover { color: #333; }

        #photoUploadModal .flex.justify-center.items-center { width: 100%; max-width: 400px; aspect-ratio: 1 / 1; margin: 1rem auto; }
        #imageCanvas { width: 100%; height: 100%; display: block; border-radius: 8px; }

        /* --- NEW: Styles for Monthly Summary Table --- */
        .monthly-summary-table th, .monthly-summary-table td { font-size: 0.55rem; padding: 4px 6px; }
        .monthly-summary-table th { font-weight: 400; text-align: center; }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">
    <!-- Global Header for the entire page (fixed at top) -->
    <div class="header-global">
        <div class="flex items-center gap-5">
            <span class="text-sm font-light">Beranda Utama</span>
        </div>
        <div class="text-center absolute left-1/2 -translate-x-1/2">
            <span id="currentDateHeader" class="text-sm"></span>
            <span id="currentTimeHeader" class="text-sm"></span>
        </div>
        
        <!-- Desktop Navigation -->
        <nav class="hidden md:flex items-center gap-5">
            <a href="index.html" class="text-sm font-light hover:underline">Home</a>
            <a href="about_new.html" class="text-sm font-light hover:underline">About</a>
            <a href="services.html" class="text-sm font-light hover:underline">Services</a>
            <a href="contact.html" class="text-sm font-light hover:underline">Contact</a>
            <a href="investasi.html" class="text-sm font-light hover:underline">Investasi</a>
            <a href="backtest.html" class="text-sm font-light hover:underline">Backtest</a>
        </nav>

        <!-- Hamburger Menu Button for Mobile -->
        <div class="md:hidden">
            <button id="hamburgerBtn" class="focus:outline-none">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
            </button>
        </div>
    </div>

    <!-- Mobile Menu (Initially Hidden) -->
    <div id="mobileMenu" class="hidden fixed inset-0 bg-white z-50 p-6 transition-transform duration-300 ease-in-out">
        <div class="flex justify-between items-center mb-8">
            <span class="text-lg font-semibold">Menu</span>
            <button id="closeMenuBtn" class="focus:outline-none">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="text-center text-gray-600 mb-8">
            <div id="mobileMenuDateTime"></div>
        </div>
        <nav class="flex flex-col items-center space-y-4">
            <a href="index.html" class="text-lg text-gray-700 hover:text-blue-600">Home</a>
            <a href="about_new.html" class="text-lg text-gray-700 hover:text-blue-600">About</a>
            <a href="services.html" class="text-lg text-gray-700 hover:text-blue-600">Services</a>
            <a href="contact.html" class="text-lg text-gray-700 hover:text-blue-600">Contact</a>
            <a href="investasi.html" class="text-lg text-gray-700 hover:text-blue-600">Investasi</a>
            <a href="backtest.html" class="text-lg text-gray-700 hover:text-blue-600">Backtest</a>
        </nav>
    </div>

    <div class="container-wrapper rounded-xl shadow-lg">
        <!-- Manually controlled photo gallery -->
        <section class="top-left-photo-section scroll-animate-section">
            <label for="imageInput" class="photo-gallery-container relative w-full max-w-sm mx-auto cursor-pointer">
                <div id="photoCarousel" class="photo-carousel relative bg-gray-100 flex items-center justify-center pointer-events-none">
                    <div id="photoSlides" class="photo-slides flex">
                        <!-- Manual images will be dynamically loaded here -->
                    </div>
                    <button id="prevPhotoBtn" class="absolute left-2 top-1/2 -translate-y-1/2 bg-black bg-opacity-50 text-white p-2 rounded-full hidden z-10 pointer-events-auto">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg>
                    </button>
                    <button id="nextPhotoBtn" class="absolute right-2 top-1/2 -translate-y-1/2 bg-black bg-opacity-50 text-white p-2 rounded-full hidden z-10 pointer-events-auto">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" /></svg>
                    </button>
                    <div id="photoCounter" class="absolute bottom-2 left-1/2 -translate-x-1/2 bg-black bg-opacity-50 text-white text-xs px-2 py-1 rounded-full hidden"></div>
                </div>
            </label>
        </section>

        <header class="header-section text-center mb-8 rounded-t-xl scroll-animate-section">
            <h1 class="text-3xl font-extralight text-primary mb-2">Risk & Reward Calculator</h1>
            <p class="text-gray-600 text-sm font-extralight">
                <span id="currentDate"></span>, <span id="currentTime"></span>
            </p>
        </header>

        <section id="calculatorInputs" class="mb-8 scroll-animate-section">
            <div id="inputRowsContainer" class="space-y-6">
                <!-- Input rows will be dynamically added here -->
            </div>

            <div class="flex flex-col sm:flex-row gap-4 mt-6">
                <button id="addInputRowBtn" class="w-full sm:flex-1 action-button">
                    Tambah Baris Input
                </button>
                <button id="calculateAllBtn" class="w-full sm:flex-1 action-button">
                    Hitung Semua
                </button>
            </div>
        </section>

        <!-- New section for Calculated/New Trading Plans -->
        <section id="newTradingPlansSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">Rencana Trading Baru</h2>
            <div class="overflow-x-auto rounded-lg border border-gray-200">
                <table class="results-table">
                    <thead>
                        <tr>
                            <th class="rounded-tl-lg">Aset</th><th>Trade</th><th>Balance Akun</th><th>Waktu Masuk</th><th>Open Price</th><th>SL Price</th><th>TP Price</th><th>Pending Pips/Points</th><th>SL Pips/Points</th><th>TP Pips/Points</th><th>R:R Pips</th><th>R:R %</th><th>Lot/Units</th><th>Nett SL</th><th>Nett TP</th><th>Catatan</th><th class="rounded-tr-lg">Aksi</th>
                        </tr>
                    </thead>
                    <tbody id="calculatedPlansBody">
                        <tr><td colspan="17" class="py-4 text-center text-gray-500">Belum ada rencana trading baru.</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Existing section, renamed to Rencana Trading Aktif -->
        <section id="runningTradingPlansSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">Rencana Trading Aktif</h2>
            <div class="overflow-x-auto rounded-lg border border-gray-200">
                <table class="results-table">
                    <thead>
                        <tr>
                            <th class="rounded-tl-lg">Aset</th><th>Trade</th><th>Balance Akun</th><th>Waktu Masuk</th><th>Open Price</th><th>SL Price</th><th>TP Price</th><th>Pending Pips/Points</th><th>SL Pips/Points</th><th>TP Pips/Points</th><th>R:R Pips</th><th>R:R %</th><th>Lot/Units</th><th>Nett SL</th><th>Nett TP</th><th>Catatan</th><th class="rounded-tr-lg">Aksi</th>
                        </tr>
                    </thead>
                    <tbody id="runningPlansBody">
                        <tr><td colspan="17" class="py-4 text-center text-gray-500">Belum ada rencana trading aktif.</td></tr>
                    </tbody>
                </table>
            </div>
            <!-- PERBAIKAN: Grid responsif untuk ringkasan rencana aktif -->
            <div id="activePlansSummary" class="hidden mt-4 p-4 bg-gray-50 border border-gray-200 rounded-lg grid grid-cols-1 sm:grid-cols-3 md:grid-cols-5 gap-4 text-center">
                <div>
                    <p class="text-xs font-medium text-gray-500 uppercase">Total SL Pips</p>
                    <p id="summaryTotalSlPips" class="text-sm font-semibold mt-1 negative-value">0</p>
                </div>
                <div>
                    <p class="text-xs font-medium text-gray-500 uppercase">Total TP Pips</p>
                    <p id="summaryTotalTpPips" class="text-sm font-semibold mt-1 positive-value">0</p>
                </div>
                <div>
                    <p class="text-xs font-medium text-gray-500 uppercase">Total Risiko %</p>
                    <p id="summaryTotalRiskPercentage" class="text-sm font-semibold mt-1 negative-value">-0.00%</p>
                </div>
                <div>
                    <p class="text-xs font-medium text-gray-500 uppercase">Total Nett SL</p>
                    <p id="summaryTotalNettSL" class="text-sm font-semibold mt-1 negative-value">$0.00</p>
                </div>
                <div>
                    <p class="text-xs font-medium text-gray-500 uppercase">Total Nett TP</p>
                    <p id="summaryTotalNettTP" class="text-sm font-semibold mt-1 positive-value">$0.00</p>
                </div>
            </div>
            <div id="calculationDetails" class="mt-6 hidden">
                <!-- Calculation details will be displayed here, but hidden by default now -->
            </div>
        </section>

        <section id="executedTradingPlansSection" class="mt-8 scroll-animate-section">
            <div class="flex flex-col sm:flex-row justify-between items-center mb-4 pb-2 border-b border-gray-200">
                <h2 class="text-lg font-extralight text-primary mb-2 sm:mb-0">Rencana Trading Selesai</h2>
                <div class="flex gap-3 mt-2 sm:mt-0">
                    <!-- NEW: "Unduh Excel" button added here -->
                    <button id="downloadExecutedExcelBtn" class="upload-data-button">Unduh Excel</button>
                    <button id="uploadDataBtn" class="upload-data-button">Unggah Data</button>
                    <button id="deleteAndExportDataBtn" class="delete-data-button">Hapus Data</button>
                </div>
            </div>
            <!-- Added a wrapper div for vertical scrolling -->
            <div id="executedPlansTableContainer" class="overflow-x-auto">
                <table class="results-table" id="executedPlansTable">
                    <thead>
                        <tr>
                            <th class="rounded-tl-lg">Aset</th><th>Trade</th><th>Balance Akun</th><th>Waktu Masuk</th><th>Open Price</th><th>SL Price</th><th>TP Price</th><th>Pending Pips/Points</th><th>SL Pips/Points</th><th>TP Pips/Points</th><th>R:R Pips</th><th>R:R %</th><th>Lot/Units</th><th>Nett SL</th><th>Nett TP</th><th>Catatan</th><th>Hasil</th><th class="rounded-tr-lg">Waktu Keluar</th>
                        </tr>
                    </thead>
                    <tbody id="executedPlansBody">
                        <tr><td colspan="18" class="py-4 text-center text-gray-500">Belum ada rencana trading yang selesai.</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- NEW: Compounding Simulator Section -->
        <section id="compoundingSimulatorSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Simulator Compounding</h2>
            <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-1 md:grid-cols-4 gap-6">
                <div>
                    <label for="simBalance" class="block text-sm input-label mb-1">Balance Awal ($)</label>
                    <input type="number" id="simBalance" placeholder="Cth: 5000" class="mt-1 block w-full input-field">
                </div>
                <div>
                    <label for="simRiskPerTrade" class="block text-sm input-label mb-1">Risk per Trade (%)</label>
                    <input type="number" id="simRiskPerTrade" placeholder="Cth: 0.5" step="0.01" class="mt-1 block w-full input-field">
                </div>
                <div>
                    <label for="simMonthlyTarget" class="block text-sm input-label mb-1">Target Bulanan (%)</label>
                    <input type="number" id="simMonthlyTarget" placeholder="Cth: 5" step="0.1" class="mt-1 block w-full input-field">
                </div>
                <div>
                    <label for="simPeriod" class="block text-sm input-label mb-1">Periode Simulasi (Bulan)</label>
                    <input type="number" id="simPeriod" placeholder="Cth: 12" class="mt-1 block w-full input-field">
                </div>
            </div>
        </section>


        <!-- New section for Overall Summary Statistics -->
        <section id="overallSummaryStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Statistik Ringkasan Keseluruhan</h2>
            <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-2 md:grid-cols-6 gap-6 text-center">
                <!-- Row 1 -->
                
                <div><p class="text-gray-600 text-sm font-light">Total Trade Selesai</p><p id="totalSettledTradesSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Probabilitas</p><p id="probabilitySummary" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Total Pips/Points</p><p id="totalPipsSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata % per Trade</p><p id="avgPercentagePerTradeSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Persentase Harian</p><p id="dailyPercentageSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Persentase Bulanan</p><p id="monthlyPercentageSummary" class="text-base mt-1">N/A</p></div>
                <!-- Row 2 -->
                <div><p class="text-gray-600 text-sm font-light">Persentase Tahunan</p><p id="yearlyPercentageSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Persentase Keseluruhan</p><p id="overallPercentageSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Saldo Akun Akhir</p><p id="finalBalanceSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Waktu Bergabung</p><p id="joinTimeSummary" class="text-base font-light text-black mt-1">N/A</p></div>
                <!-- PERUBAHAN: Penambahan data periode dan drawdown persentase -->
                <div>
                    <p class="text-gray-600 text-sm font-light">Drawdown Saldo</p>
                    <p id="balanceDrawdownSummary" class="text-base mt-1">N/A</p>
                    <p id="balanceDrawdownSummaryPeriod" class="text-xs text-gray-500 mt-1">Periode: N/A</p>
                </div>
                <div>
    <p class="text-gray-600 text-sm font-light">Maksimum Drawdown %</p>
    <p id="overallMaxDrawdownPercentage" class="text-base mt-1">N/A</p>
    <!-- TAMBAHKAN KODE DI BAWAH INI -->
    <p id="overallMaxDrawdownPercentagePeriod" class="text-xs text-gray-500 mt-1">Periode: N/A</p>
</div>
            </div>
        </section>

        <!-- New section for Risk and Reward Statistics -->
        <section id="riskRewardStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Statistik Risiko dan Imbalan</h2>
            <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4 text-center">
                <div class="sm:col-span-2 md:col-span-4 flex flex-col sm:flex-row justify-center items-center p-2 rounded-md bg-gray-100">
                    <p class="text-gray-600 text-sm font-light mr-2">Rata-rata Risiko dan Imbalan</p><p id="avgRiskReward" class="text-lg font-light text-black">1 : N/A</p>
                </div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata Sinyal Diselesaikan/Bulan</p><p id="avgSignalSettledMonth" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata Periode Penahanan</p><p id="avgHoldingPeriod" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata TP Pips</p><p id="avgTpPips" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata SL Pips</p><p id="avgSlPips" class="text-base font-light text-black mt-1">N/A</p></div>
                <!-- PERUBAHAN: Penambahan data periode -->
                <div>
                    <p class="text-gray-600 text-sm font-light">Keuntungan Beruntun</p>
                    <p id="consecutiveProfit" class="text-base font-light text-black mt-1">N/A</p>
                    <p id="consecutiveProfitPeriod" class="text-xs text-gray-500 mt-1">Periode: N/A</p>
                </div>
                <div>
                    <p class="text-gray-600 text-sm font-light">Kerugian Beruntun</p>
                    <p id="consecutiveLoss" class="text-base font-light text-black mt-1">N/A</p>
                    <p id="consecutiveLossPeriod" class="text-xs text-gray-500 mt-1">Periode: N/A</p>
                </div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata Pips</p><p id="averagePips" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Laba Kotor</p><p id="grossProfit" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rugi Kotor</p><p id="grossLoss" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata Sinyal Diselesaikan/Minggu</p><p id="avgSignalSettledWeek" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Periode Penahanan Maks</p><p id="maxHoldingPeriod" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Max TP Pips</p><p id="maxTpPips" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Max SL Pips</p><p id="maxSlPips" class="text-base font-light text-black mt-1">N/A</p></div>
                <!-- PERUBAHAN: Penambahan data periode dan drawdown bulanan -->
                <div>
                    <p class="text-gray-600 text-sm font-light">Balance Drawdown Maximal</p>
                    <p id="maxBalanceDrawdown" class="text-base font-light text-black mt-1">N/A</p>
                    <p id="maxBalanceDrawdownPeriod" class="text-xs text-gray-500 mt-1">Periode: N/A</p>
                </div>
                <div>
                    <p class="text-gray-600 text-sm font-light">Balance Drawdown Monthly</p>
                    <p id="monthlyBalanceDrawdown" class="text-base font-light text-black mt-1">N/A</p>
                    <p id="monthlyBalanceDrawdownPeriod" class="text-xs text-gray-500 mt-1">Periode: N/A</p>
                </div>
                 <div>
    <p class="text-gray-600 text-sm font-light">Maksimum Drawdown Bulanan %</p>
    <p id="monthlyMaxDrawdownPercentage" class="text-base font-light text-black mt-1">N/A</p>
    <!-- TAMBAHKAN KODE DI BAWAH INI -->
    <p id="monthlyMaxDrawdownPercentagePeriod" class="text-xs text-gray-500 mt-1">Periode: N/A</p>
</div>
        </section>

        <!-- PERBAIKAN: Bagian Ringkasan Harian, Mingguan, Bulanan, dan Tahunan -->

        <section id="newDailySummarySection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Ringkasan Harian Kumulatif</h2>
            <div class="summary-table-container overflow-x-auto">
                <table class="results-table w-full monthly-summary-table">
                    <thead>
                        <tr>
                            <th class="rounded-tl-lg">Tanggal</th>
                            <th>Presentase Kumulatif</th>
                            <th>Total Pips Kumulatif</th>
                            <th>Total Trade</th>
                            <th class="rounded-tr-lg">Saldo Akhir Kumulatif</th>
                        </tr>
                    </thead>
                    <tbody id="newDailySummaryBody">
                        <tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data untuk ditampilkan.</td></tr>
                    </tbody>
                </table>
            </div>
            <div class="flex justify-end mt-4">
                <button id="downloadNewDailySummaryBtn" class="upload-data-button">Unduh Excel</button>
            </div>
        </section>

        <section id="newWeeklySummarySection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Ringkasan Mingguan Kumulatif</h2>
            <div class="summary-table-container overflow-x-auto">
                <table class="results-table w-full monthly-summary-table">
                    <thead>
                        <tr>
                            <th class="rounded-tl-lg">Minggu</th>
                            <th>Presentase Kumulatif</th>
                            <th>Total Pips Kumulatif</th>
                            <th>Total Trade</th>
                            <th class="rounded-tr-lg">Saldo Akhir Kumulatif</th>
                        </tr>
                    </thead>
                    <tbody id="newWeeklySummaryBody">
                        <tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data untuk ditampilkan.</td></tr>
                    </tbody>
                </table>
            </div>
            <div class="flex justify-end mt-4">
                <button id="downloadNewWeeklySummaryBtn" class="upload-data-button">Unduh Excel</button>
            </div>
        </section>

        <section id="newMonthlySummarySection" class="mt-8">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Ringkasan Bulanan Kumulatif</h2>
            <div class="summary-table-container overflow-x-auto">
                <table class="results-table w-full monthly-summary-table">
                    <thead>
                        <tr>
                            <th class="rounded-tl-lg">Bulan</th>
                            <th>Presentase Kumulatif</th>
                            <th>Total Pips Kumulatif</th>
                            <th>Total Trade</th>
                            <th class="rounded-tr-lg">Saldo Akhir Kumulatif</th>
                        </tr>
                    </thead>
                    <tbody id="newMonthlySummaryBody">
                        <tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data untuk ditampilkan.</td></tr>
                    </tbody>
                </table>
            </div>
            <div class="flex justify-end mt-4">
                <button id="downloadNewMonthlySummaryBtn" class="upload-data-button">Unduh Excel</button>
            </div>
        </section>

        <section id="newYearlySummarySection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Ringkasan Tahunan Kumulatif</h2>
            <div class="summary-table-container overflow-x-auto">
                <table class="results-table w-full monthly-summary-table">
                    <thead>
                        <tr>
                            <th class="rounded-tl-lg">Tahun</th>
                            <th>Presentase Kumulatif</th>
                            <th>Total Pips Kumulatif</th>
                            <th>Total Trade</th>
                            <th class="rounded-tr-lg">Saldo Akhir Kumulatif</th>
                        </tr>
                    </thead>
                    <tbody id="newYearlySummaryBody">
                        <tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data untuk ditampilkan.</td></tr>
                    </tbody>
                </table>
            </div>
            <div class="flex justify-end mt-4">
                <button id="downloadNewYearlySummaryBtn" class="upload-data-button">Unduh Excel</button>
            </div>
        </section>
        <!-- AKHIR DARI PERBAIKAN -->


        <section id="assetSuccessStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Statistik Keberhasilan Aset</h2>
            <div id="pieChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center">
                <canvas id="assetSuccessPieChart"></canvas>
                <div id="pieChartLoading" class="hidden text-gray-500">Memuat data keberhasilan aset...</div>
                <div id="pieChartError" class="hidden error-message"></div>
                <div id="pieChartNoData" class="hidden text-gray-500">Tidak ada data keberhasilan aset yang tersedia.</div>
            </div>
        </section>

        <section id="dailyLineStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">
                Statistik Persentase Harian <span id="dailyChartDateTime" class="text-gray-600 text-sm font-light"></span>
            </h2>
            <div id="dailyLineChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="dailyLineChart"></canvas>
                <div id="dailyLineChartLoading" class="hidden text-gray-500">Memuat data statistik...</div>
                <div id="dailyLineChartError" class="hidden error-message"></div>
                <div id="dailyLineChartNoData" class="hidden text-gray-500">Tidak ada data statistik harian.</div>
            </div>
        </section>

        <section id="monthlyBarStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Statistik Persentase Bulanan (Diagram Batang)</h2>
            <div id="monthlyBarChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="monthlyBarChart"></canvas>
                <div id="monthlyBarChartLoading" class="hidden text-gray-500">Memuat data statistik...</div>
                <div id="monthlyBarChartError" class="hidden error-message"></div>
                <div id="monthlyBarChartNoData" class="hidden text-gray-500">Tidak ada data statistik bulanan.</div>
            </div>
        </section>

        <section id="overallPercentageCumulativeStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Statistik Persentase Kumulatif Keseluruhan (Acuan Balance)</h2>
            <div id="overallPercentageCumulativeChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="overallPercentageCumulativeChart"></canvas>
                <div id="overallPercentageCumulativeChartLoading" class="hidden text-gray-500">Memuat data statistik...</div>
                <div id="overallPercentageCumulativeChartError" class="hidden error-message"></div>
                <div id="overallPercentageCumulativeChartNoData" class="hidden text-gray-500">Tidak ada data statistik kumulatif keseluruhan.</div>
            </div>
        </section>

        <section id="overallBalanceCumulativeStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Statistik Saldo Akun Kumulatif Keseluruhan</h2>
            <div id="overallBalanceCumulativeChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="overallBalanceCumulativeChart"></canvas>
                <div id="overallBalanceCumulativeChartLoading" class="hidden text-gray-500">Memuat data statistik...</div>
                <div id="overallBalanceCumulativeChartError" class="hidden error-message"></div>
                <div id="overallBalanceCumulativeChartNoData" class="hidden text-gray-500">Tidak ada data statistik saldo kumulatif keseluruhan.</div>
            </div>
        </section>

        <section id="overallPipsCumulativeStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Statistik Pips/Points Kumulatif Keseluruhan</h2>
            <div id="overallPipsCumulativeChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="overallPipsCumulativeChart"></canvas>
                <div id="overallPipsCumulativeChartLoading" class="hidden text-gray-500">Memuat data statistik...</div>
                <div id="overallPipsCumulativeChartError" class="hidden error-message"></div>
                <div id="overallPipsCumulativeChartNoData" class="hidden text-gray-500">Tidak ada data statistik pips/points kumulatif keseluruhan.</div>
            </div>
        </section>

        <!-- NEW: Combined Summary Bar Chart Section -->
        <section id="combinedSummaryBarStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Ringkasan Akumulasi Gabungan (Diagram Batang)</h2>
            <div id="combinedSummaryBarChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="combinedSummaryBarChart"></canvas>
                <div id="combinedSummaryBarChartLoading" class="hidden text-gray-500">Memuat data ringkasan...</div>
                <div id="combinedSummaryBarChartError" class="hidden error-message"></div>
                <div id="combinedSummaryBarChartNoData" class="hidden text-gray-500">Tidak ada data untuk ditampilkan.</div>
            </div>
        </section>

        <!-- NEW: Balance Frequency Chart Section -->
        <section id="balanceFrequencyStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Frekuensi Balance per Aset</h2>
            <div id="balanceFrequencyChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="balanceFrequencyChart"></canvas>
                <div id="balanceFrequencyChartLoading" class="hidden text-gray-500">Memuat data frekuensi balance...</div>
                <div id="balanceFrequencyChartError" class="hidden error-message"></div>
                <div id="balanceFrequencyChartNoData" class="hidden text-gray-500">Tidak ada data untuk ditampilkan.</div>
            </div>
        </section>

        <!-- NEW: Percentage Frequency Chart Section -->
        <section id="percentageFrequencyStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Frekuensi Persentase per Aset</h2>
            <div id="percentageFrequencyChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="percentageFrequencyChart"></canvas>
                <div id="percentageFrequencyChartLoading" class="hidden text-gray-500">Memuat data frekuensi persentase...</div>
                <div id="percentageFrequencyChartError" class="hidden error-message"></div>
                <div id="percentageFrequencyChartNoData" class="hidden text-gray-500">Tidak ada data untuk ditampilkan.</div>
            </div>
        </section>

        <!-- NEW: Pips Frequency Chart Section -->
        <section id="pipsFrequencyStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Frekuensi Pips/Points per Aset</h2>
            <div id="pipsFrequencyChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="pipsFrequencyChart"></canvas>
                <div id="pipsFrequencyChartLoading" class="hidden text-gray-500">Memuat data frekuensi pips...</div>
                <div id="pipsFrequencyChartError" class="hidden error-message"></div>
                <div id="pipsFrequencyChartNoData" class="hidden text-gray-500">Tidak ada data untuk ditampilkan.</div>
            </div>
        </section>

        <!-- NEW: Execution Frequency Chart Section -->
        <section id="executionFrequencyStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Frekuensi Eksekusi per Aset (BUY vs SELL)</h2>
            <div id="executionFrequencyChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="executionFrequencyChart"></canvas>
                <div id="executionFrequencyChartLoading" class="hidden text-gray-500">Memuat data frekuensi eksekusi...</div>
                <div id="executionFrequencyChartError" class="hidden error-message"></div>
                <div id="executionFrequencyChartNoData" class="hidden text-gray-500">Tidak ada data untuk ditampilkan.</div>
            </div>
        </section>

        <!-- NEW: Asset Execution Count Chart Section -->
        <section id="assetExecutionCountStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Frekuensi Aset Selesai Dieksekusi</h2>
            <div id="assetExecutionCountChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="assetExecutionCountChart"></canvas>
                <div id="assetExecutionCountChartLoading" class="hidden text-gray-500">Memuat data frekuensi aset...</div>
                <div id="assetExecutionCountChartError" class="hidden error-message"></div>
                <div id="assetExecutionCountChartNoData" class="hidden text-gray-500">Tidak ada data untuk ditampilkan.</div>
            </div>
        </section>

        <!-- New section for Trade Frequency Chart -->
        <section id="tradeFrequencyStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200">Frekuensi Eksekusi Trade per Aset</h2>
            <div id="tradeFrequencyChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="tradeFrequencyChart"></canvas>
                <div id="tradeFrequencyChartLoading" class="hidden text-gray-500">Memuat data frekuensi trade...</div>
                <div id="tradeFrequencyChartError" class="hidden error-message"></div>
                <div id="tradeFrequencyChartNoData" class="hidden text-gray-500">Tidak ada data frekuensi trade.</div>
            </div>
        </section>


        <!-- NEW GUIDE SECTION -->
        <section class="info-section mt-8 scroll-animate-section">
            <h2>Panduan Lengkap: Menggunakan Kalkulator Risk & Reward</h2>
            <p>Selamat datang di Kalkulator Risk & Reward! Alat ini dirancang untuk menjadi asisten pribadi Anda dalam merencanakan, menghitung, dan menganalisis setiap perdagangan. Dengan memahami potensi risiko dan imbalan sebelum masuk pasar, Anda dapat membuat keputusan yang lebih cerdas dan disiplin.</p>
            
            <h3>Langkah-langkah Penggunaan</h3>
            <ol class="list-decimal list-inside space-y-4">
                <li>
                    <strong>Membuat Rencana (Input Data)</strong>
                    <p class="mt-2">Klik tombol <strong>"Tambah Baris Input"</strong> untuk memulai. Sebuah formulir akan muncul. Isi setiap kolom dengan cermat:</p>
                    <ul class="list-circle list-inside ml-4 mt-2 space-y-1">
                        <li><strong>Aset:</strong> Pilih instrumen yang akan Anda perdagangkan dari daftar.</li>
                        <li><strong>Tipe Trade:</strong> Tentukan posisi Anda dengan memilih <strong>BUY</strong> atau <strong>SELL</strong>.</li>
                        <li><strong>Balance Akun ($):</strong> Masukkan total saldo akun trading Anda saat ini.</li>
                        <li><strong>Risiko (%):</strong> Tentukan berapa persen dari saldo akun yang Anda relakan sebagai risiko untuk trade ini (misal: 0.5% atau 1%).</li>
                        <li><strong>Price Now:</strong> Harga pasar saat ini. Kolom ini digunakan untuk menghitung 'Pending Pips' dan tidak memengaruhi kalkulasi inti.</li>
                        <li><strong>Open Price:</strong> Harga di mana Anda berencana untuk membuka posisi.</li>
                        <li><strong>SL Price (Stop Loss):</strong> Harga di mana posisi akan ditutup otomatis untuk membatasi kerugian.</li>
                        <li><strong>TP Price (Take Profit):</strong> Harga di mana posisi akan ditutup otomatis untuk mengamankan keuntungan.</li>
                        <li><strong>Catatan (Opsional):</strong> Tulis catatan singkat mengenai strategi atau alasan Anda membuka posisi ini.</li>
                    </ul>
                </li>
                <li>
                    <strong>Menghitung & Memindahkan Rencana</strong>
                    <p class="mt-2">Setelah semua data terisi, klik <strong>"Hitung Semua"</strong>. Hasil perhitungan akan muncul di tabel <strong>"Rencana Trading Baru"</strong>. Dari sini, alur kerjanya adalah:</p>
                    <ul class="list-circle list-inside ml-4 mt-2 space-y-1">
                        <li><strong>Set Running:</strong> Jika Anda memutuskan untuk melanjutkan rencana ini (sebagai pending atau market order), klik tombol ini. Rencana akan pindah ke tabel <strong>"Rencana Trading Aktif"</strong>.</li>
                        <li><strong>Menyelesaikan Trade:</strong> Di tabel "Rencana Trading Aktif", setelah posisi Anda ditutup, klik <strong>"TAKE PROFIT"</strong> atau <strong>"STOP LOSS"</strong> sesuai hasil akhirnya. Rencana akan pindah ke tabel <strong>"Rencana Trading Selesai"</strong> dan semua data statistik akan diperbarui secara otomatis.</li>
                        <li><strong>Opsi Lain:</strong> Gunakan tombol <strong>"BATAL"</strong> atau <strong>"TES"</strong> untuk membatalkan rencana aktif tanpa perhitungan statistik, atau <strong>"EDIT"</strong> untuk memindahkan kembali rencana ke formulir input jika ada perubahan.</li>
                    </ul>
                </li>
            </ol>

            <h3>Memahami Hasil Kalkulasi</h3>
            <p>Berikut penjelasan untuk setiap kolom di tabel hasil:</p>
            <ul>
                <li><strong>Pending Pips/Points:</strong> Jarak antara <strong>Price Now</strong> dan <strong>Open Price</strong> Anda.</li>
                <li><strong>SL Pips/Points:</strong> Jarak (risiko) dari <strong>Open Price</strong> ke <strong>SL Price</strong>.</li>
                <li><strong>TP Pips/Points:</strong> Jarak (potensi imbalan) dari <strong>Open Price</strong> ke <strong>TP Price</strong>.</li>
                <li><strong>R:R Pips:</strong> Rasio sederhana antara TP Pips dan SL Pips. Contoh: 1:2.5 berarti potensi imbalan 2.5 kali lebih besar dari risikonya.</li>
                <li><strong>R:R %:</strong> Rasio antara persentase potensi profit dan persentase risiko dari total balance.</li>
                <li><strong>Lot/Units:</strong> Ukuran volume trading yang dihitung secara otomatis berdasarkan persentase risiko yang Anda tentukan, memastikan Anda tidak merisikokan lebih dari yang direncanakan.</li>
                <li><strong>Nett SL:</strong> Total potensi kerugian dalam mata uang Dolar jika harga menyentuh Stop Loss.</li>
                <li><strong>Nett TP:</strong> Total potensi keuntungan dalam mata uang Dolar jika harga menyentuh Take Profit.</li>
            </ul>

            <h3>Manajemen Foto & Analisis Data</h3>
            <ul class="list-disc list-inside space-y-2">
                <li><strong>Galeri Foto:</strong> Anda bisa menambahkan hingga 5 screenshot analisis (misal: dari TradingView) dengan mengklik area foto. Untuk menghapus foto, tekan dan tahan (long press) pada gambar yang ingin dihapus.</li>
                <li><strong>Statistik & Grafik:</strong> Semua bagian di bawah tabel "Rencana Trading Selesai" adalah rekapitulasi performa Anda. Gunakan grafik ini untuk menganalisis aset mana yang paling menguntungkan, bagaimana pertumbuhan akun Anda, dan kapan Anda paling sering profit atau loss.</li>
                <li><strong>Penting:</strong> Kalkulator ini adalah alat bantu jurnal dan analisis. Keputusan trading dan segala risikonya tetap menjadi tanggung jawab Anda sepenuhnya.</li>
            </ul>
        </section>

        <!-- New section for the provided text content -->
        <section class="info-section mt-8 scroll-animate-section">
            <h2 class="text-xl font-medium text-primary mb-4">Bagaimana Kasino Vegas Membuat Pemain Rugi & Mirip dengan Broker Curang</h2>
            <p class="text-base font-light text-gray-700 leading-relaxed mb-4">Baik kasino di Las Vegas maupun beberapa broker "nakal" memiliki strategi tersembunyi untuk memastikan keuntungan mereka, seringkali dengan mengorbankan pemain atau trader yang menguntungkan. Meskipun metode mereka berbeda, prinsip dasarnya sama: memanipulasi probabilitas dan informasi untuk keuntungan mereka.</p>
            <h3 class="text-lg font-semibold text-gray-800 mb-3">Alur Kasino Vegas Membuat Pemain Rugi</h3>
            <p class="text-base font-light text-gray-700 leading-relaxed mb-4">Kasino tidak perlu "curang" secara terang-terangan untuk menang; model bisnis mereka dibangun di atas keunggulan statistik yang disebut "house edge". Ini adalah persentase keuntungan jangka panjang yang dimiliki kasino atas pemain. Berikut adalah alurnya:</p>
            <ul class="list-disc list-inside mb-4">
                <li class="text-base font-light text-gray-700 mb-2"><strong>Matematika yang Tidak Menguntungkan Pemain (House Edge):</strong> Setiap permainan kasino dirancang agar kasino selalu memiliki sedikit keuntungan matematis dalam jangka panjang. Misalnya, di rolet, ada angka 0 (dan kadang 00), yang berarti peluang Anda untuk memenangkan taruhan merah/hitam sedikit kurang dari 50%. Meskipun Anda mungkin menang beberapa putaran, secara statistik, kasino akan selalu di atas angin seiring waktu.</li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Variasi dan Keberuntungan Jangka Pendek:</strong> Kasino mengandalkan fakta bahwa dalam jangka pendek, keberuntungan bisa berpihak pada pemain. Ini menciptakan ilusi bahwa pemain bisa menang besar, mendorong mereka untuk terus bermain. Kemenangan sesekali ini memicu dopamin dan membuat pemain merasa "beruntung," mendorong mereka untuk terus bertaruh.</li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Psikologi dan Lingkungan yang Memikat:</strong>
                    <ul class="list-circle list-inside ml-4 mt-1">
                        <li class="text-base font-light text-gray-700">Desain Tanpa Jendela dan Jam: Kasino dirancang untuk membuat pemain lupa waktu, mendorong mereka untuk bermain lebih lama.</li>
                        <li class="text-base font-light text-gray-700">Atmosfer Glamor dan Hiburan: Suasana yang mewah, musik, dan minuman gratis menciptakan lingkungan yang nyaman dan mendorong pengeluaran.</li>
                        <li class="text-base font-light text-gray-700">Kompensasi dan Hadiah (Comp): Kasino memberikan hadiah kecil (makanan gratis, kamar murah) kepada pemain yang kalah dalam jumlah besar atau bermain untuk waktu yang lama, membuat mereka merasa dihargai dan mendorong kunjungan kembali.</li>
                    </ul>
                </li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Kontrol Informasi dan Aturan Main:</strong> Kasino sepenuhnya mengontrol aturan main, pembayaran, dan informasi yang diberikan kepada pemain. Pemain seringkali tidak menyadari house edge yang sebenarnya atau bagaimana probabilitas bekerja melawan mereka.</li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Pengelolaan Keuangan Pemain:</strong> Kasino mendorong pemain untuk mengambil lebih banyak uang tunai, menyediakan ATM di lokasi, dan menawarkan fasilitas kredit, semuanya dirancang untuk membuat pemain terus berjudi bahkan setelah mereka kehabisan uang tunai yang mereka bawa.</li>
            </ul>

            <h3 class="text-lg font-semibold text-gray-800 mb-3">Koneksi dengan Broker Curang yang Mencurangi Trader Profitabel</h3>
            <p class="text-base font-light text-gray-700 leading-relaxed mb-4">Meskipun ranahnya berbeda, modus operasi broker nakal yang mencurangi trader profitabel memiliki kemiripan filosofis dengan cara kasino beroperasi. Perbedaannya adalah broker tersebut melakukan tindakan yang lebih eksplisit dan seringkali ilegal.</p>
            <ul class="list-disc list-inside mb-4">
                <li class="text-base font-light text-gray-700 mb-2"><strong>Manipulasi Data dan Eksekusi (House Edge Tersembunyi):</strong>
                    <ul class="list-circle list-inside ml-4 mt-1">
                        <li class="text-base font-light text-gray-700">Slippage yang Tidak Adil: Broker sengaja menerapkan slippage negatif yang besar pada pesanan trader yang profitabel, atau bahkan pada semua pesanan. Ini berarti harga eksekusi jauh lebih buruk dari harga yang diharapkan trader, mengikis keuntungan.</li>
                        <li class="text-base font-light text-gray-700">Requotes dan Penolakan Pesanan: Pesanan trader yang profitabel, terutama pada saat volatilitas tinggi, seringkali ditolak atau di-requote dengan harga yang kurang menguntungkan. Ini mengganggu strategi trading dan menyebabkan frustrasi.</li>
                        <li class="text-base font-light text-gray-700">Pemblokiran Penarikan Dana: Ini adalah bentuk kecurangan yang paling ekstrem. Ketika trader berhasil mengumpulkan keuntungan yang signifikan, broker membuat berbagai alasan (masalah verifikasi, masalah sistem) untuk menunda atau menolak penarikan dana.</li>
                    </ul>
                </li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Intervensi pada Order Flow (Memprediksi Gerakan Pemain):</strong>
                    <ul class="list-circle list-inside ml-4 mt-1">
                        <li class="text-base font-light text-gray-700">Dealing Desk (DD) vs. Non-Dealing Desk (NDD): Broker DD seringkali mengambil posisi berlawanan dengan trader mereka. Jika seorang trader sangat profitabel, broker DD mungkin akan menempatkan "stop-loss hunting" (memicu stop-loss trader secara artifisial) atau menahan harga yang menguntungkan.</li>
                        <li class="text-base font-light text-gray-700">Manipulasi Harga: Broker dapat memanipulasi feed harga mereka sendiri, terutama saat ada berita penting, untuk memicu stop-loss atau menunda take-profit trader.</li>
                    </ul>
                </li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Psikologi dan Lingkungan yang Menjebak:</strong>
                    <ul class="list-circle list-inside ml-4 mt-1">
                        <li class="text-base font-light text-gray-700">Bonus dan Promosi Palsu: Banyak broker nakal menawarkan bonus deposit yang sangat besar, tetapi dengan syarat dan ketentuan penarikan yang hampir mustahil untuk dipenuhi. Ini mengunci dana trader dan mendorong mereka untuk terus trading.</li>
                        <li class="text-base font-light text-gray-700">Edukasi yang Menyesatkan: Beberapa broker menyediakan "edukasi" yang pada dasarnya mendorong gaya trading yang tidak sehat atau terlalu agresif, yang pada akhirnya menguntungkan broker karena trader akan lebih sering kalah.</li>
                    </ul>
                </li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Kurangnya Transparansi dan Regulasi yang Lemah:</strong> Broker nakal sering beroperasi di yurisdiksi dengan regulasi yang longgar atau sama sekali tanpa regulasi. Ini memungkinkan mereka untuk melakukan praktik tidak etis tanpa takut dihukum. Mereka tidak memberikan laporan transparan tentang eksekusi order atau aliran dana.</li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Memanfaatkan Emosi Trader:</strong> Sama seperti kasino, broker nakal memanfaatkan emosi seperti keserakahan dan ketakutan. Mereka tahu bahwa trader yang emosional cenderung membuat keputusan impulsif yang menguntungkan broker.</li>
            </ul>
            <p class="text-base font-light text-gray-700 leading-relaxed">Secara ringkas, baik kasino maupun broker curang bertujuan untuk mendapatkan keuntungan jangka panjang. Kasino melakukannya melalui keunggulan matematis yang inheren dalam permainan mereka dan manipulasi lingkungan psikologis. Broker curang, di sisi lain, secara aktif memanipulasi kondisi trading, data, dan terkadang bahkan menahan dana untuk memastikan mereka "menang" melawan trader yang menguntungkan. Kedua entitas ini mengandalkan fakta bahwa mayoritas "pemain" akan kalah dalam jangka panjang, entah karena matematika atau karena manipulasi sistem.</p>
        </section>

        <!-- NEW: Download All Data Button -->
        <section class="mt-8 text-center scroll-animate-section">
            <button id="downloadAllExcelBtn" class="action-button">Unduh Semua Data (Excel)</button>
            <button id="downloadAllPdfBtn" class="action-button">Unduh Semua Data (PDF)</button>
        </section>
        
        <!-- Footer Section -->
        <footer class="w-full py-4 text-center text-gray-700 text-sm font-light mt-8">
            Leodra Sint | Think like a dealer, not like a player.
        </footer>
    </div>

    <!-- Photo Upload Modal -->
    <div id="photoUploadModal" class="modal">
        <div class="modal-content">
            <h3 class="text-lg font-semibold text-primary mb-4">Unggah & Pangkas Foto (1:1)</h3>
            <!-- This input is now visually hidden but triggered by the label -->
            <input type="file" id="imageInput" accept="image/*" class="hidden" multiple>
            <div class="flex justify-center items-center bg-gray-100 rounded-md overflow-hidden">
                <canvas id="imageCanvas"></canvas>
            </div>
            <div class="flex justify-end gap-3 mt-4">
                <button id="cancelPhotoBtn" class="action-button bg-gray-300 hover:bg-gray-400 text-gray-800">Batal</button>
                <button id="cropAndSaveBtn" class="action-button">Pangkas & Simpan</button>
            </div>
        </div>
    </div>

    <!-- PERBAIKAN: Skrip untuk fungsionalitas menu hamburger ditambahkan di sini -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const hamburgerBtn = document.getElementById('hamburgerBtn');
            const mobileMenu = document.getElementById('mobileMenu');
            const closeMenuBtn = document.getElementById('closeMenuBtn');

            hamburgerBtn.addEventListener('click', function () {
                mobileMenu.classList.remove('hidden');
            });

            closeMenuBtn.addEventListener('click', function () {
                mobileMenu.classList.add('hidden');
            });
        });
    </script>

    <script type="module">
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, collection, query, onSnapshot, addDoc, deleteDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // Global Firebase variables
        let app;
        let db;
        let auth;
        let storage;
        let userId = 'anonymous'; // Default to anonymous

        // Initialize Firebase
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Global variables for data storage
        let calculatedPlansData = []; // New: for plans that are calculated but not yet running
        let runningPlansData = [];    // Renamed from activePlansData
        let executedPlansData = [];
        let limitNotificationMessage = ''; // Global variable for limit messages

        // ... (existing constants like PENDING_PIPS_RULES, MAX_ACTIVE_RISK_PERCENT, etc.) ...
        // --- ATURAN BARU: Batas Risiko & Pending Pips ---
        const PENDING_PIPS_RULES = {
            'XAU/USD': 20,
            'EUR/USD': 5,
            'AUD/USD': 5,
            'USD/CHF': 5,
            'CHF/JPY': 7,
            'GBP/USD': 10
        };
        // PERUBAHAN: Memperbarui nilai konstanta batas risiko sesuai permintaan pengguna
        const MAX_ACTIVE_RISK_PERCENT = 2.00;  // Batas risiko aktif (sebagai persentase positif)
        const DAILY_LOSS_LIMIT = -2.50;        // Batas kerugian harian (sebagai persentase negatif)
        const MONTHLY_LOSS_LIMIT = -4.50;      // Batas kerugian bulanan (sebagai persentase negatif)
        const OVERALL_MAX_LOSS_LIMIT = -5.50;  // Batas kerugian maksimal keseluruhan (sebagai persentase negatif)
        const MAX_RISK_PER_TRADE = 0.3; 

        // --- DATA ASET & NILAI PIPS/POINTS ---
        // Menambahkan properti 'minLotIncrement' untuk setiap aset
        const assetValues = {
            'EUR/USD': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/USD': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUD/USD': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'NZD/USD': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/JPY': { decimals: 3, pipValue: 9.09, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/CAD': { decimals: 5, pipValue: 7.30, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/CHF': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/SEK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexMajor', currency: 'SEK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/NOK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexMajor', currency: 'NOK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/DKK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexMajor', currency: 'DKK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/GBP': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexCross', currency: 'GBP', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/JPY': { decimals: 3, pipValue: 9.09, contractSize: 100000, type: 'forexCross', currency: 'JPY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/JPY': { decimals: 3, pipValue: 9.09, contractSize: 100000, type: 'forexCross', currency: 'JPY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUD/JPY': { decimals: 3, pipValue: 9.09, contractSize: 100000, type: 'forexCross', currency: 'JPY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'CAD/JPY': { decimals: 3, pipValue: 9.09, contractSize: 100000, type: 'forexCross', currency: 'JPY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'CHF/JPY': { decimals: 3, pipValue: 11.20, contractSize: 100000, type: 'forexCross', currency: 'JPY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/AUD': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexCross', currency: 'AUD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/CAD': { decimals: 5, pipValue: 7.30, contractSize: 100000, type: 'forexCross', currency: 'CAD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/CHF': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexCross', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/NZD': { decimals: 5, pipValue: 6.00, contractSize: 100000, type: 'forexCross', currency: 'NZD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/AUD': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexCross', currency: 'AUD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/CAD': { decimals: 5, pipValue: 7.30, contractSize: 100000, type: 'forexCross', currency: 'CAD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/CHF': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexCross', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/NZD': { decimals: 5, pipValue: 6.00, contractSize: 100000, type: 'forexCross', currency: 'NZD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUD/CAD': { decimals: 5, pipValue: 7.30, contractSize: 100000, type: 'forexCross', currency: 'CAD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUD/CHF': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexCross', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUD/NZD': { decimals: 5, pipValue: 6.00, contractSize: 100000, type: 'forexCross', currency: 'NZD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'CAD/CHF': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexCross', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'NZD/CAD': { decimals: 5, pipValue: 7.30, contractSize: 100000, type: 'forexCross', currency: 'CAD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'NZD/CHF': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexCross', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/SEK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexCross', currency: 'SEK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/NOK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexCross', currency: 'NOK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/SEK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexCross', currency: 'SEK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/NOK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexCross', currency: 'NOK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/MXN': { decimals: 5, pipValue: 0.50, contractSize: 100000, type: 'forexExotic', currency: 'MXN', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/ZAR': { decimals: 5, pipValue: 0.05, contractSize: 100000, type: 'forexExotic', currency: 'ZAR', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/TRY': { decimals: 5, pipValue: 0.03, contractSize: 100000, type: 'forexExotic', currency: 'TRY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/SGD': { decimals: 5, pipValue: 0.74, contractSize: 100000, type: 'forexExotic', currency: 'SGD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/HKD': { decimals: 5, pipValue: 1.28, contractSize: 100000, type: 'forexExotic', currency: 'HKD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/TRY': { decimals: 5, pipValue: 0.03, contractSize: 100000, type: 'forexExotic', currency: 'TRY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/TRY': { decimals: 5, pipValue: 0.03, contractSize: 100000, type: 'forexExotic', currency: 'TRY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUD/SGD': { decimals: 5, pipValue: 0.74, contractSize: 100000, type: 'forexExotic', currency: 'SGD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'NZD/SGD': { decimals: 5, pipValue: 0.74, contractSize: 100000, type: 'forexExotic', currency: 'SGD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'CAD/SGD': { decimals: 5, pipValue: 0.74, contractSize: 100000, type: 'forexExotic', currency: 'CAD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'CHF/SGD': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexExotic', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/PLN': { decimals: 5, pipValue: 0.25, contractSize: 100000, type: 'forexExotic', currency: 'PLN', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/HUF': { decimals: 5, pipValue: 0.003, contractSize: 100000, type: 'forexExotic', currency: 'HUF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/CZK': { decimals: 5, pipValue: 0.04, contractSize: 100000, type: 'forexExotic', currency: 'CZK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'XAU/USD': { decimals: 2, pipValue: 100.00, contractSize: 100, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'XAG/USD': { decimals: 3, pipValue: 50.00, contractSize: 5000, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'WTI/USD': { decimals: 2, pipValue: 10.00, contractSize: 1000, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'BRENT/USD': { decimals: 2, pipValue: 10.00, contractSize: 1000, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'NATGAS/USD': { decimals: 3, pipValue: 10.00, contractSize: 10000, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'COPPER/USD': { decimals: 4, pipValue: 25000.00, contractSize: 25000, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'PLATINUM/USD': { decimals: 2, pipValue: 50.00, contractSize: 50, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            
        };

        // --- GLOBAL VARIABLES DOM ELEMENTS ---
        let rowCounter = 0;
        const inputRowsContainer = document.getElementById('inputRowsContainer');
        const calculatedPlansBody = document.getElementById('calculatedPlansBody'); // New element
        const runningPlansBody = document.getElementById('runningPlansBody'); // Renamed from activePlansData
        const executedPlansBody = document.getElementById('executedPlansBody');
        const calculationDetailsContainer = document.getElementById('calculationDetails');
        const dailyChartDateTime = document.getElementById('dailyChartDateTime');
        const deleteAndExportDataBtn = document.getElementById('deleteAndExportDataBtn');
        const uploadDataBtn = document.getElementById('uploadDataBtn');
        const photoCarousel = document.getElementById('photoCarousel'); // New carousel container
        const photoSlides = document.getElementById('photoSlides'); // New slides container
        const prevPhotoBtn = document.getElementById('prevPhotoBtn'); // New prev button
        const nextPhotoBtn = document.getElementById('nextPhotoBtn'); // New next button
        const photoCounter = document.getElementById('photoCounter'); // New photo counter
        const imageInput = document.getElementById('imageInput');
        const imageCanvas = document.getElementById('imageCanvas');
        const ctx = imageCanvas.getContext('2d');
        const photoUploadModal = document.getElementById('photoUploadModal');
        const cropAndSaveBtn = document.getElementById('cropAndSaveBtn');
        const cancelPhotoBtn = document.getElementById('cancelPhotoBtn');
        let currentImageToCrop = null; // Stores the image currently being cropped
        let userPhotos = []; // Array to store all user photo URLs
        let currentPhotoIndex = 0; // Index of the currently displayed photo
        const MAX_PHOTOS = 8;
        // NEW: Download buttons
        const downloadExecutedExcelBtn = document.getElementById('downloadExecutedExcelBtn');
        const downloadAllExcelBtn = document.getElementById('downloadAllExcelBtn');
        const lihatkanDataBtn = document.getElementById('lihatkanDataBtn');
        const downloadNewMonthlySummaryBtn = document.getElementById('downloadNewMonthlySummaryBtn');

        let scrollObserver; // Variabel global untuk instance IntersectionObserver
        let dailyLineChart = null, monthlyBarChart = null, assetPieChart = null, overallPercentageCumulativeChart = null, overallBalanceCumulativeChart = null, overallPipsCumulativeChart = null, tradeFrequencyChart = null;
let combinedBarChart = null;
let balanceFrequencyChart = null, percentageFrequencyChart = null, pipsFrequencyChart = null;
let executionFrequencyChart = null;
let assetExecutionCountChart = null; // <-- TAMBAHKAN BARIS INI
        // --- HELPER FUNCTIONS ---
        // Modified formatNumber to control thousands grouping
        const formatNumber = (value, decimals = 2, useGrouping = true) => {
            if (isNaN(value) || value === null || !isFinite(value)) return 'N/A';
            const num = parseFloat(value);
            if (useGrouping) {
                // Use toLocaleString for grouping (e.g., for currency, balance, etc.)
                return num.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
            } else {
                // Use toFixed for raw numerical string with specified decimals, no grouping
                return num.toFixed(decimals);
            }
        };

        const formatCurrency = (value, currency = 'USD') => (isNaN(value) || value === null || !isFinite(value)) ? 'N/A' : parseFloat(value).toLocaleString('en-US', { style: 'currency', currency: currency, minimumFractionDigits: 2, maximumFractionDigits: 2 });
        const getColoredValueHtml = (value, isCurrency = false, decimals = 2) => {
            if (value === 'N/A' || isNaN(value) || !isFinite(value)) return `<span class="text-black">N/A</span>`;
            const formattedValue = isCurrency ? formatCurrency(value, 'USD') : formatNumber(value, decimals);
            const colorClass = value >= 0 ? 'text-black' : 'text-red-500';
            return `<span class="${colorClass}">${formattedValue}</span>`;
        };
        function updateDateTime() {
            const now = new Date();
            const dateOptions = { weekday: 'long', year: 'numeric', month: 'short', day: 'numeric' };
            const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true };
            const fullDateTimeString = `${now.toLocaleDateString('id-ID', dateOptions)} ${now.toLocaleTimeString('id-ID', timeOptions)}`;
            
            document.getElementById('currentDate').textContent = now.toLocaleDateString('id-ID', dateOptions);
            document.getElementById('currentTime').textContent = now.toLocaleTimeString('id-ID', timeOptions);
            document.getElementById('currentDateHeader').textContent = now.toLocaleDateString('id-ID', dateOptions);
            document.getElementById('currentTimeHeader').textContent = now.toLocaleTimeString('id-ID', timeOptions);
            if (dailyChartDateTime) dailyChartDateTime.textContent = `(${fullDateTimeString})`;
            
            // Update date/time in mobile menu
            const mobileMenuDateTime = document.getElementById('mobileMenuDateTime');
            if (mobileMenuDateTime) {
                mobileMenuDateTime.textContent = fullDateTimeString;
            }
        }
        const getRandomColor = (index) => `hsl(${(index * 137.508) % 360}, 70%, 50%)`;
        
        // --- HELPER FUNCTIONS ---
// ... (existing helper functions like formatNumber, formatCurrency, getColoredValueHtml, updateDateTime, getRandomColor, getStepValue, getVisualPoints, showModal, hideModal, showMessageBox, updateActivePlansSummary) ...

// PERBAIKAN: Memperbarui fungsi formatDuration untuk menampilkan "N/A" jika durasi 0
function formatDuration(milliseconds) {
    if (isNaN(milliseconds) || milliseconds <= 0) return 'N/A';
    const seconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (days > 0) {
        return `${days} Hari`;
    } else if (hours > 0) {
        return `${hours} Jam`;
    } else if (minutes > 0) {
        return `${minutes} Menit`;
    } else if (seconds > 0) {
        return `${seconds} Detik`;
    }
    return '< 1 Detik'; // Default jika kurang dari 1 detik tapi lebih dari 0
}
        // Fungsi pembantu baru untuk mengatur atribut step
        function getStepValue(decimals) {
            if (decimals <= 0) return '1'; // Untuk bilangan bulat
            return '0.' + '0'.repeat(decimals - 1) + '1';
        }

        /**
         * START OF FIX: Updated pips/points formatting and calculation logic.
         * This function now formats the visual display AND provides the value for calculation.
         * @param {number} pipsValue The precise pips value (e.g., 12.5).
         * @param {string} symbol The asset symbol (e.g., 'XAU/USD').
         * @param {boolean} isForExecutedTable - NEW: Flag to determine display format.
         * @returns {{display: string, forCalc: number}} An object with the display string and the number for calculation.
         */
        function getVisualPoints(pipsValue, symbol, isForExecutedTable = false) {
            if (isNaN(pipsValue) || pipsValue === null || !isFinite(pipsValue)) {
                return { display: 'N/A', forCalc: 0 };
            }

            const assetData = getAssetData(symbol);
            const isCommodityOrIndex = assetData && (assetData.type === 'commodity' || assetData.type === 'index');

            // Mengonversi pips ke poin (misal: 12.5 pips -> 125 poin)
            const pointsValue = Math.round(Math.abs(parseFloat(pipsValue)) * 10);
            const pointsString = pointsValue.toString();

            if (isCommodityOrIndex) {
                // Untuk komoditas dan indeks, tampilkan dan hitung dengan nilai poin penuh
                return { display: pointsString, forCalc: pointsValue };
            } else {
                // Untuk aset lain (forex):
                // Nilai untuk kalkulasi tetap sama, menjaga logika lot size inti.
                const visualStringForCalc = pointsString.length > 1 ? pointsString.slice(0, -1) : pointsString;
                const forCalc = parseInt(visualStringForCalc, 10) || 0;

                // PERBAIKAN: Nilai tampilan berubah berdasarkan flag.
                // Jika untuk tabel yang sudah selesai, tampilkan poin penuh. Jika tidak, tampilkan versi yang dipotong.
                const displayString = isForExecutedTable ? pointsString : visualStringForCalc;
                
                return { display: displayString, forCalc: forCalc };
            }
        }


        // Helper functions for modals
        function showModal(modalElement) { modalElement.classList.add('show'); }
        function hideModal(modalElement) { modalElement.classList.remove('show'); }

        /**
         * Displays a custom modal message box.
         * @param {string} title The title of the message box.
         * @param {string} message The main message content, can include HTML.
         * @param {boolean} isConfirm If true, shows "Batal/Ya" buttons and returns a Promise. If false, shows "OK" button.
         * @returns {Promise<boolean>|void} Returns a Promise resolving to true/false for confirm, or void for alert.
         */
        function showMessageBox(title, message, isConfirm = false) {
            return new Promise(resolve => {
                // Remove any existing message box first
                const existingModal = document.querySelector('.message-box-modal');
                if (existingModal) {
                    existingModal.remove();
                }

                const modal = document.createElement('div');
                modal.className = 'modal message-box-modal'; // Add a specific class
                modal.innerHTML = `
                    <div class="modal-content">
                        <button class="modal-close-button" id="closeMessageBoxBtn">&times;</button>
                        <h3 class="text-lg font-semibold text-primary mb-4">${title}</h3>
                        <p class="text-gray-700 mb-6">${message}</p>
                        <div class="flex justify-end gap-3 mt-4">
                            ${isConfirm ? `
                                <button id="cancelMessageBoxBtn" class="action-button bg-gray-500 hover:bg-gray-600">Batal</button>
                                <button id="confirmMessageBoxBtn" class="action-button">Ya</button>
                            ` : `
                                <button id="okMessageBoxBtn" class="action-button">OK</button>
                            `}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                // Use a short timeout to allow the element to be in the DOM before adding the 'show' class for transition
                setTimeout(() => showModal(modal), 10);

                const closeBtn = modal.querySelector('#closeMessageBoxBtn');
                const okBtn = modal.querySelector('#okMessageBoxBtn');
                const cancelBtn = modal.querySelector('#cancelMessageBoxBtn');
                const confirmBtn = modal.querySelector('#confirmMessageBoxBtn');

                const hideAndResolve = (result) => {
                    hideModal(modal);
                    modal.addEventListener('transitionend', () => modal.remove(), { once: true });
                    resolve(result);
                };

                if (closeBtn) closeBtn.addEventListener('click', () => hideAndResolve(false));
                if (okBtn) okBtn.addEventListener('click', () => hideAndResolve(true));
                if (cancelBtn) cancelBtn.addEventListener('click', () => hideAndResolve(false));
                if (confirmBtn) confirmBtn.addEventListener('click', () => hideAndResolve(true));
            });
        }

        /**
         * PERBAIKAN: Fungsi untuk memperbarui ringkasan rencana aktif.
         */
        function updateActivePlansSummary() {
            const summaryContainer = document.getElementById('activePlansSummary');
            if (!summaryContainer) return;

            const totalSlPipsEl = document.getElementById('summaryTotalSlPips');
            const totalTpPipsEl = document.getElementById('summaryTotalTpPips');
            const totalRiskPercentageEl = document.getElementById('summaryTotalRiskPercentage');
            const totalNettSLEl = document.getElementById('summaryTotalNettSL');
            const totalNettTPEl = document.getElementById('summaryTotalNettTP');

            if (runningPlansData.length === 0) {
                summaryContainer.classList.add('hidden');
                return;
            }
            summaryContainer.classList.remove('hidden');

            let totalSlPips = 0;
            let totalTpPips = 0;
            let totalRiskPercentage = 0;
            let totalNettSL = 0;
            let totalNettTP = 0;

            runningPlansData.forEach(plan => {
                // Gunakan poin visual untuk ringkasan agar sesuai dengan tabel
                totalSlPips += getVisualPoints(plan.slPips, plan.symbol).forCalc;
                totalTpPips += getVisualPoints(plan.tpPips, plan.symbol).forCalc;
                if (plan.rrPercentage && plan.rrPercentage.sl) {
                    totalRiskPercentage += plan.rrPercentage.sl;
                }
                totalNettSL += plan.nettSL;
                totalNettTP += plan.nettTP;
            });

            totalSlPipsEl.textContent = formatNumber(totalSlPips, 0);
            totalTpPipsEl.textContent = formatNumber(totalTpPips, 0);
            totalRiskPercentageEl.textContent = `-${formatNumber(totalRiskPercentage, 2)}%`;
            totalNettSLEl.textContent = formatCurrency(totalNettSL, 'USD');
            totalNettTPEl.textContent = formatCurrency(totalNettTP, 'USD');

            // PERBAIKAN: Pastikan Total SL Pips selalu berwarna merah
            totalSlPipsEl.className = 'text-sm font-semibold mt-1 negative-value';
            totalTpPipsEl.className = 'text-sm font-semibold mt-1 ' + (totalTpPips > 0 ? 'positive-value' : 'negative-value');
            totalNettTPEl.className = 'text-sm font-semibold mt-1 ' + (totalNettTP > 0 ? 'positive-value' : 'negative-value');
        }


        // --- FIREBASE STORAGE FUNCTIONS ---
        async function loadProfilePictures(uid) {
            if (!storage) {
                console.warn("Firebase Storage is not initialized. Using localStorage for photos.");
                loadPhotosFromLocalStorage();
                renderPhotoGallery();
                return;
            }

            let permissionErrorOccurred = false;
            userPhotos = [];
            const loadPromises = [];

            for (let i = 0; i < MAX_PHOTOS; i++) {
                const imageRef = ref(storage, `artifacts/${appId}/users/${uid}/profile_${i}.png`);
                loadPromises.push(getDownloadURL(imageRef)
                    .then(url => ({ url, index: i }))
                    .catch(error => {
                        if (error.code === 'storage/unauthorized') {
                            // Set flag jika terjadi error izin, jangan log di sini untuk menghindari spam.
                            permissionErrorOccurred = true;
                        } else if (error.code !== 'storage/object-not-found') {
                            // Log error lain yang tidak terduga, abaikan jika file tidak ditemukan (ini normal).
                            console.error(`Error loading profile picture profile_${i}.png:`, error);
                        }
                        return null; // Kembalikan null untuk setiap kegagalan muat.
                    })
                );
            }

            const results = await Promise.all(loadPromises);

            // Jika error izin terdeteksi, tangani sekarang secara terpusat.
            if (permissionErrorOccurred) {
                console.error("Firebase Storage Permission Error: User does not have permission to access profile pictures. Please check your Firebase Storage Security Rules to ensure read access for authenticated users (e.g., 'allow read: if request.auth != null;'). Falling back to localStorage for photos.");
                loadPhotosFromLocalStorage(); // Fallback ke data lokal
                renderPhotoGallery();
                return; // Hentikan eksekusi lebih lanjut
            }

            // Jika tidak ada error izin, lanjutkan seperti biasa.
            results.forEach(result => {
                if (result) {
                    userPhotos[result.index] = result.url;
                }
            });
            userPhotos = userPhotos.filter(url => url); // Bersihkan slot kosong
            console.log("Profile pictures loaded from Firebase Storage:", userPhotos.length);
            renderPhotoGallery();
            savePhotosToLocalStorage(); // Sinkronkan dengan local storage
        }

        async function saveProfilePicture(uid, imageDataUrl, index) {
            if (!storage) {
                console.warn("Firebase Storage is not initialized. Cannot save profile picture.");
                userPhotos[index] = imageDataUrl; // Update in memory
                savePhotosToLocalStorage(); // Fallback to local storage
                renderPhotoGallery();
                return;
            }
            try {
                const imageRef = ref(storage, `artifacts/${appId}/users/${uid}/profile_${index}.png`);
                const response = await fetch(imageDataUrl);
                const blob = await response.blob();
                await uploadBytes(imageRef, blob);
                
                // Update local state AFTER successful upload
                userPhotos[index] = imageDataUrl; 
                console.log(`Profile picture profile_${index}.png saved to Firebase Storage.`);
                
                // --- PERBAIKAN DITAMBAHKAN DI SINI ---
                // Selalu sinkronkan dengan local storage setelah berhasil menyimpan ke Firebase.
                savePhotosToLocalStorage(); 
                // --- AKHIR PERBAIKAN ---

                showMessageBox('Berhasil', 'Foto profil berhasil disimpan.', false);
                renderPhotoGallery(); // Update display after successful save
            } catch (error) {
                if (error.code === 'storage/unauthorized') {
                    console.error("Firebase Storage Permission Error: User does not have permission to save profile picture. Please check your Firebase Storage Security Rules to ensure write access for authenticated users (e.g., 'allow write: if request.auth != null;').", error);
                    showMessageBox('Gagal', 'Tidak ada izin untuk menyimpan foto. Periksa aturan keamanan Firebase Anda.', false);
                } else {
                    console.error(`Error saving profile picture profile_${index}.png to Firebase:`, error);
                    showMessageBox('Gagal', 'Terjadi kesalahan saat menyimpan foto. Silakan coba lagi.', false);
                }
            }
        }

        async function deleteProfilePicture(uid, indexToDelete) {
            if (!storage) {
                console.warn("Firebase Storage is not initialized. Cannot delete profile picture.");
                userPhotos.splice(indexToDelete, 1); // Remove from array
                savePhotosToLocalStorage(); // Fallback to local storage
                renderPhotoGallery();
                return;
            }
            try {
                const imageRef = ref(storage, `artifacts/${appId}/users/${uid}/profile_${indexToDelete}.png`);
                await deleteObject(imageRef);
                console.log(`Profile picture profile_${indexToDelete}.png deleted from Firebase Storage.`);
                userPhotos.splice(indexToDelete, 1); // Remove from array
                // Re-index remaining photos in Firebase storage to fill the gap
                for (let i = indexToDelete; i < userPhotos.length; i++) {
                    const oldRef = ref(storage, `artifacts/${appId}/users/${uid}/profile_${i + 1}.png`);
                    const newRef = ref(storage, `artifacts/${appId}/users/${uid}/profile_${i}.png`);
                    // This is a workaround as Firebase Storage doesn't have a direct "rename" or "move" operation.
                    // We re-upload the next image to the current slot and then delete the old one.
                    try {
                        const url = await getDownloadURL(oldRef);
                        const response = await fetch(url);
                        const blob = await await response.blob();
                        await uploadBytes(newRef, blob);
                        await deleteObject(oldRef);
                        userPhotos[i] = url; // Update local array with the moved image
                    } catch (error) {
                        if (error.code === 'storage/object-not-found') {
                            // No next image to shift, stop re-indexing
                            break;
                        } else {
                            console.error(`Error re-indexing photo from ${i + 1} to ${i}:`, error);
                        }
                    }
                }
                // Finally, delete the last photo if it was shifted
                if (userPhotos.length < MAX_PHOTOS) { // Check if there's a potential leftover at the end
                    const lastPossibleRef = ref(storage, `artifacts/${appId}/users/${uid}/profile_${userPhotos.length}.png`);
                    try {
                        await deleteObject(lastPossibleRef);
                    } catch (error) {
                        if (error.code === 'storage/object-not-found') { /* fine */ }
                        else { console.error("Error deleting last shifted photo:", error); }
                    }
                }
                savePhotosToLocalStorage(); // Keep local storage in sync
                renderPhotoGallery();
            } catch (error) {
                console.error("Error deleting profile picture from Firebase Storage:", error);
                // Even if Firebase delete fails, try to update local storage and re-render
                userPhotos.splice(indexToDelete, 1);
                savePhotosToLocalStorage();
                renderPhotoGallery();
            }
        }

        // --- FIREBASE FIRESTORE FUNCTIONS (No changes needed here for photo functionality) ---
        async function loadCalculatedPlans(uid) {
            if (!db) return;
            try {
                const q = query(collection(db, `artifacts/${appId}/users/${uid}/calculatedPlans`));
                onSnapshot(q, (snapshot) => {
                    calculatedPlansData = snapshot.docs.map(doc => {
                        const data = doc.data();
                        data.assetData = getAssetData(data.symbol);
                        return data;
                    });
                    console.log("Calculated plans loaded from Firestore:", calculatedPlansData.length);
                    renderCalculatedPlans();
                    saveDataToLocalStorage(); // Keep local storage in sync
                }, (error) => {
                    console.error("Error listening to calculated plans from Firestore:", error);
                });
            } catch (error) {
                console.error("Error setting up Firestore listener for calculated plans:", error);
            }
        }

        async function saveCalculatedPlan(uid, plan) {
            if (!db) return;
            try {
                await setDoc(doc(db, `artifacts/${appId}/users/${uid}/calculatedPlans`, plan.rowId), plan);
                console.log("Calculated plan saved to Firestore:", plan.rowId);
            } catch (error) {
                console.error("Error saving calculated plan to Firestore:", error);
            }
        }

        async function deleteCalculatedPlan(uid, rowId) {
            if (!db) return;
            try {
                await deleteDoc(doc(db, `artifacts/${appId}/users/${uid}/calculatedPlans`, rowId));
                console.log("Calculated plan deleted from Firestore:", rowId);
            } catch (error) {
                console.error("Error deleting calculated plan from Firestore:", error);
            }
        }

        async function loadRunningPlans(uid) {
            if (!db) return;
            try {
                const q = query(collection(db, `artifacts/${appId}/users/${uid}/runningPlans`));
                onSnapshot(q, (snapshot) => {
                    runningPlansData = snapshot.docs.map(doc => {
                        const data = doc.data();
                        data.assetData = getAssetData(data.symbol);
                        return data;
                    });
                    console.log("Running plans loaded from Firestore:", runningPlansData.length);
                    renderRunningPlans();
                    saveDataToLocalStorage(); // Keep local storage in sync
                }, (error) => {
                    console.error("Error listening to running plans from Firestore:", error);
                });
            } catch (error) {
                console.error("Error setting up Firestore listener for running plans:", error);
            }
        }

        async function saveRunningPlan(uid, plan) {
            if (!db) return;
            try {
                await setDoc(doc(db, `artifacts/${appId}/users/${uid}/runningPlans`, plan.rowId), plan);
                console.log("Running plan saved to Firestore:", plan.rowId);
            } catch (error) {
                console.error("Error saving running plan to Firestore:", error);
            }
        }

        async function deleteRunningPlan(uid, rowId) {
            if (!db) return;
            try {
                await deleteDoc(doc(db, `artifacts/${appId}/users/${uid}/runningPlans`, rowId));
                console.log("Running plan deleted from Firestore:", rowId);
            } catch (error) {
                console.error("Error deleting running plan from Firestore:", error);
            }
        }

        // --- PERBAIKAN STRUKTURAL: FUNGSI loadExecutedPlans YANG SUDAH DIBERSIHKAN ---
        async function loadExecutedPlans(uid) {
            if (!db) {
                console.warn("Firestore is not initialized. Cannot load executed plans.");
                initializeAppFromLocalStorage(); // Fallback jika DB tidak ada
                return;
            }
            try {
                const q = query(collection(db, `artifacts/${appId}/users/${uid}/executedPlans`));
                onSnapshot(q, (snapshot) => {
                    const plans = snapshot.docs.map(doc => {
                        const data = doc.data();
                        data.assetData = getAssetData(data.symbol);
                        return data;
                    });
                    
                    executedPlansData = plans.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                    console.log("Executed plans loaded from Firestore:", executedPlansData.length);
                    
                    // Alur yang Benar: Render tabel, lalu hitung semua statistik & ringkasan
                    renderExecutedPlans();
                    calculateSummaryStatistics();
                    updateRiskRewardStatistics();
                    
                    // --- PERBAIKAN DIMULAI DI SINI: Panggil semua fungsi ringkasan ---
                    // Menambahkan panggilan ini memastikan ringkasan harian, mingguan, bulanan,
                    // dan tahunan diperbarui setiap kali ada data baru dari unggahan atau penyelesaian trade.
                    calculateAndRenderDailySummary();
                    calculateAndRenderWeeklySummary();
                    calculateAndRenderNewMonthlySummary();
                    calculateAndRenderYearlySummary();
                    // --- AKHIR PERBAIKAN ---

                    saveDataToLocalStorage(); 
                }, (error) => {
                    console.error("Error listening to executed plans from Firestore:", error);
                    initializeAppFromLocalStorage(); // Fallback jika ada error listener
                });
            } catch (error) {
                console.error("Error setting up Firestore listener for executed plans:", error);
                initializeAppFromLocalStorage(); // Fallback jika setup listener gagal
            }
        }


        async function saveExecutedPlan(uid, plan) {
            if (!db) {
                console.warn("Firestore is not initialized. Cannot save executed plan.");
                return;
            }
            try {
                await addDoc(collection(db, `artifacts/${appId}/users/${uid}/executedPlans`), plan);
                console.log("Executed plan saved to Firestore.");
            } catch (error) {
                console.error("Error saving executed plan to Firestore:", error);
            }
        }

        async function deleteAllExecutedPlans(uid) {
            if (!db) {
                console.warn("Firestore is not initialized. Cannot delete all executed plans.");
                return;
            }
            try {
                const q = query(collection(db, `artifacts/${appId}/users/${uid}/executedPlans`));
                const snapshot = await getDocs(q);
                const deletePromises = [];
                snapshot.forEach(doc => {
                    deletePromises.push(deleteDoc(doc.ref));
                });
                await Promise.all(deletePromises);
                console.log("All executed plans deleted from Firestore.");
            } catch (error) {
                console.error("Error deleting all executed plans from Firestore:", error);
            }
        }

        async function deleteAllCalculatedPlans(uid) {
            if (!db) return;
            try {
                const q = query(collection(db, `artifacts/${appId}/users/${uid}/calculatedPlans`));
                const snapshot = await getDocs(q);
                const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));
                await Promise.all(deletePromises);
                console.log("All calculated plans deleted from Firestore.");
            } catch (error) {
                console.error("Error deleting all calculated plans from Firestore:", error);
            }
        }

        async function deleteAllRunningPlans(uid) {
            if (!db) return;
            try {
                const q = query(collection(db, `artifacts/${appId}/users/${uid}/runningPlans`));
                const snapshot = await getDocs(q);
                const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));
                await Promise.all(deletePromises);
                console.log("All running plans deleted from Firestore.");
            } catch (error) {
                console.error("Error deleting all running plans from Firestore:", error);
            }
        }

        // --- LOCAL STORAGE FUNCTIONS (Used as fallback if Firebase is not configured or fails) ---
        function saveDataToLocalStorage() {
            try {
                localStorage.setItem('calculatedPlansData', JSON.stringify(calculatedPlansData));
                localStorage.setItem('runningPlansData', JSON.stringify(runningPlansData));
                localStorage.setItem('executedPlansData', JSON.stringify(executedPlansData));
                console.log("Data saved to localStorage.");
            }
            catch (e) { console.error("Error saving to localStorage:", e); }
        }
        function loadDataFromLocalStorage() {
            try {
                calculatedPlansData = JSON.parse(localStorage.getItem('calculatedPlansData')) || [];
                runningPlansData = JSON.parse(localStorage.getItem('runningPlansData')) || [];
                executedPlansData = JSON.parse(localStorage.getItem('executedPlansData')) || [];
                console.log("Data loaded from localStorage. Calculated Plans:", calculatedPlansData.length, "Running Plans:", runningPlansData.length, "Executed Plans:", executedPlansData.length);
            }
            catch (e) { console.error("Error loading from localStorage:", e); calculatedPlansData = []; runningPlansData = []; executedPlansData = []; }
        }

        // --- Photo Local Storage (separate for photos) ---
        function savePhotosToLocalStorage() {
            try {
                localStorage.setItem('userPhotos', JSON.stringify(userPhotos));
                console.log("Photos saved to localStorage.");
            } catch (e) {
                console.error("Error saving photos to localStorage:", e);
            }
        }

        function loadPhotosFromLocalStorage() {
            try {
                userPhotos = JSON.parse(localStorage.getItem('userPhotos')) || [];
                console.log("Photos loaded from localStorage:", userPhotos.length);
            } catch (e) {
                console.error("Error loading photos from localStorage:", e);
                userPhotos = [];
            }
        }

        // --- Simulator Local Storage ---
        function saveSimulatorData() {
            try {
                const simData = {
                    balance: document.getElementById('simBalance').value,
                    risk: document.getElementById('simRiskPerTrade').value,
                    target: document.getElementById('simMonthlyTarget').value,
                    period: document.getElementById('simPeriod').value
                };
                localStorage.setItem('compoundingSimulatorData', JSON.stringify(simData));
            } catch(e) {
                console.error("Error saving simulator data to localStorage:", e);
            }
        }

        function loadSimulatorData() {
            try {
                const simData = JSON.parse(localStorage.getItem('compoundingSimulatorData'));
                if (simData) {
                    document.getElementById('simBalance').value = simData.balance || '';
                    document.getElementById('simRiskPerTrade').value = simData.risk || '';
                    document.getElementById('simMonthlyTarget').value = simData.target || '';
                    document.getElementById('simPeriod').value = simData.period || '';
                }
            } catch (e) {
                console.error("Error loading simulator data from localStorage:", e);
            }
        }
        
        // --- Input Rows Local Storage ---
        function saveInputRowsToLocalStorage() {
            try {
                const inputRows = document.querySelectorAll('.input-row');
                const dataToSave = [];
                inputRows.forEach(row => {
                    const rowId = row.id.split('-')[1];
                    const rowData = {
                        symbol: row.querySelector(`#symbol-${rowId}`).value,
                        tradeType: row.querySelector(`#buyBtn-${rowId}`).classList.contains('active') ? 'BUY' : 'SELL',
                        balance: row.querySelector(`#balance-${rowId}`).value,
                        riskPercent: row.querySelector(`#riskPercent-${rowId}`).value,
                        priceNow: row.querySelector(`#priceNow-${rowId}`).value,
                        openPrice: row.querySelector(`#openPrice-${rowId}`).value,
                        slPrice: row.querySelector(`#slPrice-${rowId}`).value,
                        tpPrice: row.querySelector(`#tpPrice-${rowId}`).value,
                        note: row.querySelector(`#note-${rowId}`).value,
                    };
                    dataToSave.push(rowData);
                });
                localStorage.setItem('calculatorInputRows', JSON.stringify(dataToSave));
            } catch (e) {
                console.error("Error saving input rows to localStorage:", e);
            }
        }

        function loadInputRowsFromLocalStorage() {
            try {
                const savedRows = JSON.parse(localStorage.getItem('calculatorInputRows'));
                if (savedRows && savedRows.length > 0) {
                    inputRowsContainer.innerHTML = ''; // Clear any default rows
                    savedRows.forEach(rowData => addInputRow(rowData));
                    return true; // Indicate that data was loaded
                }
                return false; // No data found
            } catch (e) {
                console.error("Error loading input rows from localStorage:", e);
                return false;
            }
        }


        // --- CHART.JS RENDERING FUNCTIONS (simplified error/loading handling) ---
        const setupChartContainer = (canvasId, loadingId, errorId, noDataId) => {
            const canvas = document.getElementById(canvasId);
            const loading = document.getElementById(loadingId);
            const error = document.getElementById(errorId);
            const noData = document.getElementById(noDataId);
            loading.classList.remove('hidden'); error.classList.add('hidden'); noData.classList.add('hidden'); canvas.style.display = 'none';
            return { canvas, loading, error, noData };
        };

        const handleChartData = (data, { canvas, loading, error, noData }, chartInstanceRef, chartType, options) => {
            loading.classList.add('hidden');
            // Check if data is empty or if all values are zero for pie chart
            if (data.labels.length === 0 || (chartType === 'pie' && data.datasets && data.datasets.length > 0 && data.datasets[0].data.every(val => val === 0))) {
                noData.classList.remove('hidden'); canvas.style.display = 'none'; return false;
            }
            canvas.style.display = 'block';
            if (chartInstanceRef.chart) chartInstanceRef.chart.destroy();
            chartInstanceRef.chart = new Chart(canvas, { type: chartType, data: { labels: data.labels, datasets: data.datasets }, options });
            return true;
        };

        async function fetchAndRenderDailyLineChart() {
            const { canvas, loading, error, noData } = setupChartContainer('dailyLineChart', 'dailyLineChartLoading', 'dailyLineChartError', 'dailyLineChartNoData');
            try {
                const now = new Date(); const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0).getTime();
                const tradesToday = executedPlansData.filter(trade => {
                    const tradeTimestamp = new Date(trade.timestamp).getTime();
                    return tradeTimestamp >= todayStart && tradeTimestamp <= now.getTime() && trade.outcome !== 'Cancel' && trade.outcome !== 'Tes';
                }).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                const labels = [], data = []; let currentCumulativePercentage = 0, dailyInitialBalance = null;
                tradesToday.forEach(trade => {
                    if (dailyInitialBalance === null) dailyInitialBalance = trade.balance;
                    let profitLoss = (trade.outcome === 'Take Profit') ? trade.nettTP : (trade.outcome === 'Stop Loss' ? trade.nettSL : 0);
                    if (tradesToday.length > 0 && tradesToday[0].balance !== 0) {
                        currentCumulativePercentage = ((dailyInitialBalance + profitLoss - tradesToday[0].balance) / tradesToday[0].balance) * 100;
                        dailyInitialBalance += profitLoss;
                    } else { currentCumulativePercentage = 0; }
                    labels.push(new Date(trade.timestamp).toLocaleString('id-ID', { weekday: 'long', year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' }));
                    data.push(currentCumulativePercentage);
                });

                handleChartData({ labels, datasets: [{ label: 'Persentase Harian', data, borderColor: '#222', backgroundColor: 'rgba(34, 34, 34, 0.1)', fill: true, tension: 0.3, borderWidth: 1, pointRadius: 3, pointBackgroundColor: '#222', pointBorderColor: '#fff', pointHoverRadius: 5, pointHoverBackgroundColor: '#222', pointHoverBorderColor: '#fff' }] }, { canvas, loading, error, noData }, { chart: dailyLineChart, set chart(c) { dailyLineChart = c; } }, 'line', { responsive: true, maintainAspectRatio: false, animation: { duration: 1000, easing: 'easeOutQuart' }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + formatNumber(ctx.raw, 2) + '%' } } }, scales: { x: { title: { display: true, text: 'Tanggal & Waktu Transaksi Hari Ini', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { color: '#555', font: { family: 'Inter', size: 7 } } }, y: { beginAtZero: true, title: { display: true, text: 'Persentase Harian Kumulatif (%)', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { callback: val => formatNumber(val, 2) + '%', color: '#555', font: { family: 'Inter', size: 7 } } } } });
            } catch (err) { console.error("Error daily line chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik harian: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        async function fetchAndRenderMonthlyBarChart() {
            const { canvas, loading, error, noData } = setupChartContainer('monthlyBarChart', 'monthlyBarChartLoading', 'monthlyBarChartError', 'monthlyBarChartNoData');
            try {
                executedPlansData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const monthlyStatsMap = {};
                executedPlansData.forEach(trade => {
                    if (trade.outcome === 'Cancel' || trade.outcome === 'Tes') return;
                    const monthYear = `${new Date(trade.timestamp).getFullYear()}-${(new Date(trade.timestamp).getMonth() + 1).toString().padStart(2, '0')}`;
                    if (!monthlyStatsMap[monthYear]) monthlyStatsMap[monthYear] = { initialBalance: trade.balance, currentBalance: trade.balance };
                    monthlyStatsMap[monthYear].currentBalance += (trade.outcome === 'Take Profit') ? trade.nettTP : (trade.outcome === 'Stop Loss' ? trade.nettSL : 0);
                });
                const labels = Object.keys(monthlyStatsMap).sort();
                const data = labels.map(my => monthlyStatsMap[my].initialBalance !== 0 ? ((monthlyStatsMap[my].currentBalance - monthlyStatsMap[my].initialBalance) / monthlyStatsMap[my].initialBalance) * 100 : 0);
                const backgroundColors = data.map(val => val >= 0 ? 'rgba(34, 34, 34, 0.8)' : 'rgba(220, 53, 69, 0.8)');

                handleChartData({ labels, datasets: [{ label: 'Persentase Perubahan Bulanan', data, backgroundColor: backgroundColors, borderColor: backgroundColors.map(c => c.replace('0.8)', '1)')), borderWidth: 1 }] }, { canvas, loading, error, noData }, { chart: monthlyBarChart, set chart(c) { monthlyBarChart = c; } }, 'bar', { responsive: true, maintainAspectRatio: false, animation: { duration: 800 }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + formatNumber(ctx.raw, 2) + '%' } } }, scales: { x: { title: { display: true, text: 'Bulan', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { color: '#555', font: { family: 'Inter', size: 7 } } }, y: { beginAtZero: true, title: { display: true, text: 'Persentase (%)', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { callback: val => formatNumber(val, 2) + '%', color: '#555', font: { family: 'Inter', size: 7 } } } } });
            } catch (err) { console.error("Error monthly bar chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik batang bulanan: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        async function fetchAndRenderPieChart() {
            const { canvas, loading, error, noData } = setupChartContainer('assetSuccessPieChart', 'pieChartLoading', 'pieChartError', 'pieChartNoData');
            try {
                const takeProfitTradesByAsset = {}; let totalTakeProfitTrades = 0;
                executedPlansData.forEach(trade => { if (trade.outcome === 'Take Profit') { takeProfitTradesByAsset[trade.symbol] = (takeProfitTradesByAsset[trade.symbol] || 0) + 1; totalTakeProfitTrades++; } });

                const labels = [], data = [], backgroundColors = []; let colorIndex = 0;
                for (const symbol in takeProfitTradesByAsset) {
                    const percentage = (takeProfitTradesByAsset[symbol] / totalTakeProfitTrades) * 100;
                    labels.push(`${symbol} (${formatNumber(percentage, 2)}%)`); data.push(percentage); backgroundColors.push(getRandomColor(colorIndex++));
                }

                handleChartData({ labels, datasets: [{ data, backgroundColor: backgroundColors, hoverOffset: 10, borderColor: '#fff', borderWidth: 2 }] }, { canvas, loading, error, noData }, { chart: assetPieChart, set chart(c) { assetPieChart = c; } }, 'pie', { responsive: true, maintainAspectRatio: false, animation: { duration: 800 }, plugins: { legend: { display: true, position: 'bottom', labels: { color: '#333', font: { family: 'Inter', size: 10, weight: '300' }, padding: 15, boxWidth: 12 } }, tooltip: { callbacks: { label: ctx => `${ctx.label || ''}: ${formatNumber(ctx.raw, 2)}%` }, spacing: 10 } } });
            } catch (err) { console.error("Error pie chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik keberhasilan aset: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        async function fetchAndRenderOverallPercentageCumulativeChart() {
            const { canvas, loading, error, noData } = setupChartContainer('overallPercentageCumulativeChart', 'overallPercentageCumulativeChartLoading', 'overallPercentageCumulativeChartError', 'overallPercentageCumulativeChartNoData');
            try {
                const sortedTrades = [...executedPlansData].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                const actualLabels = [], actualData = [];
                let initialBalance = null, currentBalance = null;
                sortedTrades.forEach(trade => {
                    if (trade.outcome === 'Cancel' || trade.outcome === 'Tes') return;
                    if (initialBalance === null) {
                        initialBalance = trade.balance;
                        currentBalance = trade.balance;
                    }
                    currentBalance += (trade.outcome === 'Take Profit') ? trade.nettTP : (trade.outcome === 'Stop Loss' ? trade.nettSL : 0);
                    actualLabels.push(new Date(trade.timestamp).toLocaleString('id-ID', { day: 'numeric', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' }));
                    actualData.push(initialBalance !== 0 ? ((currentBalance - initialBalance) / initialBalance) * 100 : 0);
                });

                const { projectionLabels, projectionData } = calculateProjectionData('percentage');
                const combinedLabels = [...actualLabels, ...projectionLabels];
                const actualDataset = {
                    label: 'Persentase Aktual',
                    data: actualData,
                    borderColor: '#007bff',
                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                    fill: true, tension: 0.3, borderWidth: 1.5,
                    pointRadius: 2, pointBackgroundColor: '#007bff'
                };

                const projectionDataset = {
                    label: 'Proyeksi',
                    data: [...new Array(actualData.length - 1).fill(null), actualData[actualData.length - 1], ...projectionData],
                    borderColor: 'rgba(0, 123, 255, 0.5)',
                    borderDash: [5, 5],
                    fill: false, tension: 0.3, borderWidth: 1.5,
                    pointRadius: 2, pointBackgroundColor: 'rgba(0, 123, 255, 0.5)'
                };

                const datasets = [actualDataset];
                if (projectionData.length > 0) {
                    datasets.push(projectionDataset);
                }

                // **PERUBAHAN DI SINI:** Menggunakan fungsi bantuan baru untuk skala
                const scalesConfig = getResponsiveChartScales(
                    combinedLabels, 
                    'Persentase Kumulatif (%)', 
                    val => formatNumber(val, 2) + '%'
                );

                handleChartData({ labels: combinedLabels, datasets }, { canvas, loading, error, noData }, { chart: overallPercentageCumulativeChart, set chart(c) { overallPercentageCumulativeChart = c; } }, 'line', { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    animation: { duration: 1000, easing: 'easeOutQuart' }, 
                    plugins: { 
                        legend: { display: true, position: 'top' }, 
                        tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + formatNumber(ctx.raw, 2) + '%' } } 
                    }, 
                    scales: scalesConfig // Menggunakan konfigurasi skala yang baru
                });

            } catch (err) { console.error("Error overall cumulative percentage chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik kumulatif keseluruhan: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        async function fetchAndRenderOverallBalanceCumulativeChart() {
            const { canvas, loading, error, noData } = setupChartContainer('overallBalanceCumulativeChart', 'overallBalanceCumulativeChartLoading', 'overallBalanceCumulativeChartError', 'overallBalanceCumulativeChartNoData');
            try {
                const sortedTrades = [...executedPlansData].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                const actualLabels = [], actualData = [];
                let currentBalance = null;
                sortedTrades.forEach(trade => {
                    if (trade.outcome === 'Cancel' || trade.outcome === 'Tes') return;
                    if (currentBalance === null) currentBalance = trade.balance;
                    currentBalance += (trade.outcome === 'Take Profit') ? trade.nettTP : (trade.outcome === 'Stop Loss' ? trade.nettSL : 0);
                    actualLabels.push(new Date(trade.timestamp).toLocaleString('id-ID', { day: 'numeric', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' }));
                    actualData.push(currentBalance);
                });

                const { projectionLabels, projectionData } = calculateProjectionData('balance');
                const combinedLabels = [...actualLabels, ...projectionLabels];
                const actualDataset = {
                    label: 'Saldo Aktual',
                    data: actualData,
                    borderColor: '#dc3545',
                    backgroundColor: 'rgba(220, 53, 69, 0.1)',
                    fill: true, tension: 0.3, borderWidth: 1.5,
                    pointRadius: 2, pointBackgroundColor: '#dc3545'
                };

                const projectionDataset = {
                    label: 'Proyeksi',
                    data: [...new Array(actualData.length - 1).fill(null), actualData[actualData.length - 1], ...projectionData],
                    borderColor: 'rgba(220, 53, 69, 0.5)',
                    borderDash: [5, 5],
                    fill: false, tension: 0.3, borderWidth: 1.5,
                    pointRadius: 2, pointBackgroundColor: 'rgba(220, 53, 69, 0.5)'
                };
                
                const datasets = [actualDataset];
                if (projectionData.length > 0) {
                    datasets.push(projectionDataset);
                }

                // **PERUBAHAN DI SINI:** Menggunakan fungsi bantuan baru untuk skala
                const scalesConfig = getResponsiveChartScales(
                    combinedLabels,
                    'Saldo Akun ($)',
                    val => formatCurrency(val, 'USD')
                );

                handleChartData({ labels: combinedLabels, datasets }, { canvas, loading, error, noData }, { chart: overallBalanceCumulativeChart, set chart(c) { overallBalanceCumulativeChart = c; } }, 'line', { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    animation: { duration: 1000, easing: 'easeOutQuart' }, 
                    plugins: { 
                        legend: { display: true, position: 'top' }, 
                        tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + formatCurrency(ctx.raw, 'USD') } } 
                    }, 
                    scales: scalesConfig // Menggunakan konfigurasi skala yang baru
                });
            
            } catch (err) { console.error("Error overall cumulative balance chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik saldo kumulatif keseluruhan: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }


        async function fetchAndRenderOverallPipsCumulativeChart() {
            const { canvas, loading, error, noData } = setupChartContainer('overallPipsCumulativeChart', 'overallPipsCumulativeChartLoading', 'overallPipsCumulativeChartError', 'overallPipsCumulativeChartNoData');
            try {
                executedPlansData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const labels = [], data = [];
                let currentCumulativePoints = 0;
                executedPlansData.forEach(trade => {
                    if (trade.outcome === 'Cancel' || trade.outcome === 'Tes') return;
                    
                    let pointsForTrade = 0;
                    if (trade.outcome === 'Take Profit') {
                        pointsForTrade = getVisualPoints(trade.tpPips, trade.symbol).forCalc;
                    } else if (trade.outcome === 'Stop Loss') {
                        pointsForTrade = -getVisualPoints(trade.slPips, trade.symbol).forCalc;
                    }
                    currentCumulativePoints += pointsForTrade;

                    labels.push(new Date(trade.timestamp).toLocaleString('id-ID', { day: 'numeric', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' }));
                    data.push(currentCumulativePoints);
                });

                // **PERUBAHAN DI SINI:** Menggunakan fungsi bantuan baru untuk skala
                const scalesConfig = getResponsiveChartScales(
                    labels,
                    'Pips/Points',
                    val => formatNumber(val, 0),
                    true // Parameter ke-4: yBeginAtZero
                );

                handleChartData({ labels, datasets: [{ label: 'Pips/Points Kumulatif Keseluruhan', data, borderColor: '#ffc107', backgroundColor: 'rgba(255, 193, 7, 0.1)', fill: true, tension: 0.3, borderWidth: 1, pointRadius: 3, pointBackgroundColor: '#ffc107', pointBorderColor: '#fff', pointHoverRadius: 5, pointHoverBackgroundColor: '#ffc107', pointHoverBorderColor: '#fff' }] }, { canvas, loading, error, noData }, { chart: overallPipsCumulativeChart, set chart(c) { overallPipsCumulativeChart = c; } }, 'line', { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    animation: { duration: 1000, easing: 'easeOutQuart' }, 
                    plugins: { 
                        legend: { display: false }, 
                        tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + formatNumber(ctx.raw, 0) } } 
                    }, 
                    scales: scalesConfig // Menggunakan konfigurasi skala yang baru
                });
            } catch (err) { console.error("Error overall cumulative pips chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik pips/points kumulatif keseluruhan: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        async function fetchAndRenderCombinedBarChart() {
            const { canvas, loading, error, noData } = setupChartContainer('combinedSummaryBarChart', 'combinedSummaryBarChartLoading', 'combinedSummaryBarChartError', 'combinedSummaryBarChartNoData');
            try {
                const sortedTrades = [...executedPlansData]
                    .filter(trade => trade.outcome === 'Take Profit' || trade.outcome === 'Stop Loss')
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                if (sortedTrades.length === 0) {
                    handleChartData({ labels: [], datasets: [] }, { canvas, loading, error, noData }, { chart: combinedBarChart, set chart(c) { combinedBarChart = c; } }, 'bar', {});
                    return;
                }

                const labels = [];
                const balanceData = [];
                // Objek untuk menyimpan data tambahan untuk tooltip
                const tooltipData = [];

                let initialBalance = sortedTrades[0].balance;
                let cumulativeBalance = initialBalance;
                let cumulativePips = 0;
                let cumulativeTradeCount = 0;

                sortedTrades.forEach((trade, index) => {
                    const profitLossAmount = (trade.outcome === 'Take Profit') ? trade.nettTP : trade.nettSL;
                    const pointsForTrade = (trade.outcome === 'Take Profit') ? getVisualPoints(trade.tpPips, trade.symbol).forCalc : -getVisualPoints(trade.slPips, trade.symbol).forCalc;

                    cumulativeBalance += profitLossAmount;
                    cumulativePips += pointsForTrade;
                    cumulativeTradeCount++;
                    const cumulativePercentage = initialBalance > 0 ? ((cumulativeBalance - initialBalance) / initialBalance) * 100 : 0;

                    labels.push(`Trade #${index + 1}`);
                    balanceData.push(cumulativeBalance);
                    tooltipData.push({
                        percentage: cumulativePercentage,
                        pips: cumulativePips,
                        trades: cumulativeTradeCount
                    });
                });

                const scalesConfig = getResponsiveChartScales(
                    labels,
                    'Akumulasi Saldo ($)',
                    val => formatCurrency(val, 'USD')
                );

                handleChartData({
                    labels,
                    datasets: [{
                        label: 'Akumulasi Saldo',
                        data: balanceData,
                        backgroundColor: 'rgba(220, 53, 69, 0.8)', // Warna merah
                        borderColor: 'rgba(220, 53, 69, 1)',
                        borderWidth: 1
                    }]
                }, { canvas, loading, error, noData }, { chart: combinedBarChart, set chart(c) { combinedBarChart = c; } }, 'bar', {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: { duration: 800 },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                // Menampilkan data gabungan di tooltip
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const balance = context.raw;
                                    const extraData = tooltipData[index];
                                    return `Saldo: ${formatCurrency(balance, 'USD')}`;
                                },
                                afterLabel: function(context) {
                                    const index = context.dataIndex;
                                    const extraData = tooltipData[index];
                                    return [
                                        `Persentase: ${formatNumber(extraData.percentage, 2)}%`,
                                        `Total Pips: ${formatNumber(extraData.pips, 0)}`,
                                        `Total Trade: ${extraData.trades}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: scalesConfig
                });
            } catch (err) {
                console.error("Error combined bar chart:", err);
                loading.classList.add('hidden');
                error.textContent = 'Gagal memuat data grafik gabungan: ' + err.message;
                error.classList.remove('hidden');
                canvas.style.display = 'none';
            }
        }



        async function fetchAndRenderTradeFrequencyChart() {
            const { canvas, loading, error, noData } = setupChartContainer('tradeFrequencyChart', 'tradeFrequencyChartLoading', 'tradeFrequencyChartError', 'tradeFrequencyChartNoData');
            try {
                const tradeCounts = {};
                executedPlansData.forEach(trade => { if (trade.outcome !== 'Cancel' && trade.outcome !== 'Tes') { const key = `${trade.symbol} - ${trade.tradeType}`; tradeCounts[key] = (tradeCounts[key] || 0) + 1; } });
                const labels = Object.keys(tradeCounts).sort();
                const data = labels.map(label => tradeCounts[label]);
                const backgroundColors = labels.map(label => label.includes('BUY') ? 'rgba(34, 34, 34, 0.8)' : (label.includes('SELL') ? 'rgba(220, 53, 69, 0.8)' : 'rgba(108, 117, 125, 0.8)'));
                const borderColors = backgroundColors.map(c => c.replace('0.8)', '1)'));

                handleChartData({ labels, datasets: [{ label: 'Jumlah Eksekusi', data, backgroundColor: backgroundColors, borderColor: borderColors, borderWidth: 1 }] }, { canvas, loading, error, noData }, { chart: tradeFrequencyChart, set chart(c) { tradeFrequencyChart = c; } }, 'bar', { responsive: true, maintainAspectRatio: false, animation: { duration: 800 }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => `${ctx.label}: ${ctx.raw} kali` } } }, scales: { x: { title: { display: true, text: 'Aset & Tipe Trade', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { color: '#555', font: { family: 'Inter', size: 7 }, autoSkip: false, maxRotation: 45, minRotation: 45 } }, y: { beginAtZero: true, title: { display: true, text: 'Jumlah Eksekusi', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { callback: val => Number.isInteger(val) ? val : null, color: '#555', font: { family: 'Inter', size: 7 } } } } });
            } catch (err) { console.error("Error trade frequency chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik frekuensi trade: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        // --- NEW: Functions for Frequency Charts ---

        /**
         * Generic data aggregation function for frequency charts.
         * @returns {Object} Aggregated data grouped by asset symbol.
         */
        function aggregateAssetFrequencyData() {
            const assetStats = {};
            const relevantTrades = executedPlansData.filter(trade => trade.outcome === 'Take Profit' || trade.outcome === 'Stop Loss');

            // Find the first trade for each asset to establish its initial balance for percentage calculation
            const initialBalances = {};
            [...relevantTrades].sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp)).forEach(trade => {
                if (!initialBalances[trade.symbol]) {
                    initialBalances[trade.symbol] = trade.balance;
                }
            });

            relevantTrades.forEach(trade => {
                const symbol = trade.symbol;
                if (!assetStats[symbol]) {
                    assetStats[symbol] = {
                        tradeCount: 0,
                        cumulativeBalance: 0,
                        cumulativePips: 0,
                        initialBalance: initialBalances[symbol] || 0 // Use the found initial balance
                    };
                }

                const profitLossAmount = (trade.outcome === 'Take Profit') ? trade.nettTP : trade.nettSL;
                const pointsForTrade = (trade.outcome === 'Take Profit') ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

                assetStats[symbol].tradeCount++;
                assetStats[symbol].cumulativeBalance += profitLossAmount;
                assetStats[symbol].cumulativePips += pointsForTrade;
            });

            // Calculate cumulative percentage for each asset
            for (const symbol in assetStats) {
                const stats = assetStats[symbol];
                stats.cumulativePercentage = (stats.initialBalance > 0) ? (stats.cumulativeBalance / stats.initialBalance) * 100 : 0;
            }

            return assetStats;
        }

        /**
         * Generic rendering function for horizontal frequency bar charts.
         */
        async function renderFrequencyChart(chartConfig) {
            const { canvas, loading, error, noData } = setupChartContainer(chartConfig.canvasId, chartConfig.loadingId, chartConfig.errorId, chartConfig.noDataId);
            try {
                const assetStats = aggregateAssetFrequencyData();
                const sortedSymbols = Object.keys(assetStats).sort((a, b) => assetStats[b][chartConfig.dataKey] - assetStats[a][chartConfig.dataKey]);

                if (sortedSymbols.length === 0) {
                    handleChartData({ labels: [], datasets: [] }, { canvas, loading, error, noData }, chartConfig.chartInstanceRef, 'bar', {});
                    return;
                }

                const labels = sortedSymbols;
                const data = sortedSymbols.map(symbol => assetStats[symbol][chartConfig.dataKey]);
                
                // Use the provided color, with a lighter version for negative values
                const backgroundColors = data.map(val => val >= 0 ? chartConfig.positiveColor : chartConfig.negativeColor);
                const borderColors = backgroundColors.map(c => c.replace('0.8)', '1)').replace('0.4)', '0.6)'));

                handleChartData({
                    labels,
                    datasets: [{
                        label: chartConfig.label,
                        data,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 1
                    }]
                }, { canvas, loading, error, noData }, chartConfig.chartInstanceRef, 'bar', {
                    indexAxis: 'y', // Make it a horizontal bar chart
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: { duration: 800 },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const symbol = context.label;
                                    const value = context.raw;
                                    const tradeCount = assetStats[symbol].tradeCount;
                                    return `${chartConfig.label}: ${chartConfig.formatter(value)} (Total Trade: ${tradeCount})`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: chartConfig.xAxisLabel, color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } },
                            ticks: { callback: chartConfig.formatter, color: '#555', font: { family: 'Inter', size: 7 } }
                        },
                        y: {
                            ticks: { color: '#555', font: { family: 'Inter', size: 7 } }
                        }
                    }
                });

            } catch (err) {
                console.error(`Error rendering ${chartConfig.label} chart:`, err);
                loading.classList.add('hidden');
                error.textContent = `Gagal memuat data ${chartConfig.label}: ` + err.message;
                error.classList.remove('hidden');
                canvas.style.display = 'none';
            }
        }

        // Specific functions that call the generic renderer
        async function fetchAndRenderBalanceFrequencyChart() {
            await renderFrequencyChart({
                canvasId: 'balanceFrequencyChart', loadingId: 'balanceFrequencyChartLoading', errorId: 'balanceFrequencyChartError', noDataId: 'balanceFrequencyChartNoData',
                chartInstanceRef: { chart: balanceFrequencyChart, set chart(c) { balanceFrequencyChart = c; } },
                dataKey: 'cumulativeBalance',
                label: 'Akumulasi Balance',
                xAxisLabel: 'Total Balance ($)',
                formatter: (val) => formatCurrency(val, 'USD'),
                positiveColor: 'rgba(220, 53, 69, 0.8)',  // Red
                negativeColor: 'rgba(220, 53, 69, 0.4)'   // Lighter Red
            });
        }

        async function fetchAndRenderPercentageFrequencyChart() {
            await renderFrequencyChart({
                canvasId: 'percentageFrequencyChart', loadingId: 'percentageFrequencyChartLoading', errorId: 'percentageFrequencyChartError', noDataId: 'percentageFrequencyChartNoData',
                chartInstanceRef: { chart: percentageFrequencyChart, set chart(c) { percentageFrequencyChart = c; } },
                dataKey: 'cumulativePercentage',
                label: 'Akumulasi Persentase',
                xAxisLabel: 'Total Persentase (%)',
                formatter: (val) => `${formatNumber(val, 2)}%`,
                positiveColor: 'rgba(0, 0, 139, 0.8)',    // Dark Blue
                negativeColor: 'rgba(0, 0, 139, 0.4)'     // Lighter Dark Blue
            });
        }

        async function fetchAndRenderPipsFrequencyChart() {
            await renderFrequencyChart({
                canvasId: 'pipsFrequencyChart', loadingId: 'pipsFrequencyChartLoading', errorId: 'pipsFrequencyChartError', noDataId: 'pipsFrequencyChartNoData',
                chartInstanceRef: { chart: pipsFrequencyChart, set chart(c) { pipsFrequencyChart = c; } },
                dataKey: 'cumulativePips',
                label: 'Akumulasi Pips/Points',
                xAxisLabel: 'Total Pips/Points',
                formatter: (val) => formatNumber(val, 0),
                positiveColor: 'rgba(255, 193, 7, 0.8)',  // Yellow
                negativeColor: 'rgba(255, 193, 7, 0.4)'   // Lighter Yellow
            });
        }

        // --- NEW: Functions for Execution Frequency Chart ---

        /**
         * Aggregates executed trade data, separating stats by asset and trade type (BUY/SELL).
         * @returns {Object} Aggregated data.
         */
        function aggregateExecutionFrequencyData() {
            const assetStats = {};
            const relevantTrades = executedPlansData.filter(trade => trade.outcome === 'Take Profit' || trade.outcome === 'Stop Loss');

            // Find the initial balance for each asset to calculate percentage changes accurately.
            const initialBalances = {};
            [...relevantTrades].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)).forEach(trade => {
                if (!initialBalances[trade.symbol]) {
                    initialBalances[trade.symbol] = trade.balance;
                }
            });

            relevantTrades.forEach(trade => {
                const symbol = trade.symbol;
                const tradeType = trade.tradeType.toUpperCase(); // 'BUY' or 'SELL'

                // Initialize structure if it doesn't exist
                if (!assetStats[symbol]) {
                    assetStats[symbol] = {
                        BUY: { tradeCount: 0, cumulativeBalance: 0, cumulativePips: 0, initialBalance: initialBalances[symbol] || 0 },
                        SELL: { tradeCount: 0, cumulativeBalance: 0, cumulativePips: 0, initialBalance: initialBalances[symbol] || 0 }
                    };
                }

                const profitLossAmount = (trade.outcome === 'Take Profit') ? trade.nettTP : trade.nettSL;
                const pointsForTrade = (trade.outcome === 'Take Profit') ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

                if (assetStats[symbol][tradeType]) {
                    assetStats[symbol][tradeType].tradeCount++;
                    assetStats[symbol][tradeType].cumulativeBalance += profitLossAmount;
                    assetStats[symbol][tradeType].cumulativePips += pointsForTrade;
                }
            });

            // Calculate cumulative percentage for each asset and trade type
            for (const symbol in assetStats) {
                for (const tradeType in assetStats[symbol]) {
                    const stats = assetStats[symbol][tradeType];
                    stats.cumulativePercentage = (stats.initialBalance > 0) ? (stats.cumulativeBalance / stats.initialBalance) * 100 : 0;
                }
            }

            return assetStats;
        }

        /**
         * Renders the horizontal grouped bar chart for execution frequency.
         */
        async function fetchAndRenderExecutionFrequencyChart() {
            const { canvas, loading, error, noData } = setupChartContainer('executionFrequencyChart', 'executionFrequencyChartLoading', 'executionFrequencyChartError', 'executionFrequencyChartNoData');
            try {
                const assetStats = aggregateExecutionFrequencyData();
                const sortedSymbols = Object.keys(assetStats).sort((a, b) => {
                    const totalBalanceA = (assetStats[a].BUY.cumulativeBalance || 0) + (assetStats[a].SELL.cumulativeBalance || 0);
                    const totalBalanceB = (assetStats[b].BUY.cumulativeBalance || 0) + (assetStats[b].SELL.cumulativeBalance || 0);
                    return totalBalanceB - totalBalanceA;
                });

                if (sortedSymbols.length === 0) {
                    handleChartData({ labels: [], datasets: [] }, { canvas, loading, error, noData }, { chart: executionFrequencyChart, set chart(c) { executionFrequencyChart = c; } }, 'bar', {});
                    return;
                }

                const labels = sortedSymbols;
                const buyData = sortedSymbols.map(symbol => assetStats[symbol].BUY.cumulativeBalance);
                const sellData = sortedSymbols.map(symbol => assetStats[symbol].SELL.cumulativeBalance);

                handleChartData({
                    labels,
                    datasets: [
                        {
                            label: 'BUY',
                            data: buyData,
                            backgroundColor: 'rgba(0, 0, 139, 0.8)', // Dark Blue
                            borderColor: 'rgba(0, 0, 139, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'SELL',
                            data: sellData,
                            backgroundColor: 'rgba(220, 53, 69, 0.8)', // Red
                            borderColor: 'rgba(220, 53, 69, 1)',
                            borderWidth: 1
                        }
                    ]
                }, { canvas, loading, error, noData }, { chart: executionFrequencyChart, set chart(c) { executionFrequencyChart = c; } }, 'bar', {
                    indexAxis: 'y', // Horizontal bar chart
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: { duration: 800 },
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    return context.dataset.label; // Just show BUY or SELL
                                },
                                afterLabel: (context) => {
                                    const symbol = context.label;
                                    const tradeType = context.dataset.label;
                                    const stats = assetStats[symbol][tradeType];
                                    return [
                                        `  Saldo: ${formatCurrency(stats.cumulativeBalance, 'USD')}`,
                                        `  Persentase: ${formatNumber(stats.cumulativePercentage, 2)}%`,
                                        `  Pips/Points: ${formatNumber(stats.cumulativePips, 0)}`,
                                        `  Total Trade: ${stats.tradeCount}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Akumulasi Saldo ($)', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } },
                            ticks: { callback: (val) => formatCurrency(val, 'USD'), color: '#555', font: { family: 'Inter', size: 7 } }
                        },
                        y: {
                            ticks: { color: '#555', font: { family: 'Inter', size: 7 } }
                        }
                    }
                });

            } catch (err) {
                console.error("Error rendering execution frequency chart:", err);
                loading.classList.add('hidden');
                error.textContent = 'Gagal memuat data frekuensi eksekusi: ' + err.message;
                error.classList.remove('hidden');
                canvas.style.display = 'none';
            }
        }

        /**
         * Renders the horizontal bar chart for total executed trades per asset.
         */
        async function fetchAndRenderAssetExecutionCountChart() {
            const { canvas, loading, error, noData } = setupChartContainer('assetExecutionCountChart', 'assetExecutionCountChartLoading', 'assetExecutionCountChartError', 'assetExecutionCountChartNoData');
            try {
                const assetCounts = {};
                const relevantTrades = executedPlansData.filter(trade => trade.outcome === 'Take Profit' || trade.outcome === 'Stop Loss');

                relevantTrades.forEach(trade => {
                    const symbol = trade.symbol;
                    assetCounts[symbol] = (assetCounts[symbol] || 0) + 1;
                });

                const sortedSymbols = Object.keys(assetCounts).sort((a, b) => assetCounts[b] - assetCounts[a]);

                if (sortedSymbols.length === 0) {
                    handleChartData({ labels: [], datasets: [] }, { canvas, loading, error, noData }, { chart: assetExecutionCountChart, set chart(c) { assetExecutionCountChart = c; } }, 'bar', {});
                    return;
                }

                const labels = sortedSymbols;
                const data = sortedSymbols.map(symbol => assetCounts[symbol]);

                handleChartData({
                    labels,
                    datasets: [{
                        label: 'Jumlah Eksekusi',
                        data,
                        backgroundColor: 'rgba(132, 204, 22, 0.8)', // Bright Green
                        borderColor: 'rgba(101, 163, 13, 1)',
                        borderWidth: 1
                    }]
                }, { canvas, loading, error, noData }, { chart: assetExecutionCountChart, set chart(c) { assetExecutionCountChart = c; } }, 'bar', {
                    indexAxis: 'y', // Horizontal bar chart
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: { duration: 800 },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => `Jumlah Eksekusi: ${context.raw}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Jumlah Eksekusi Selesai', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } },
                            ticks: { 
                                color: '#555', 
                                font: { family: 'Inter', size: 7 },
                                stepSize: 1 // Ensure ticks are integers
                            }
                        },
                        y: {
                            ticks: { color: '#555', font: { family: 'Inter', size: 7 } }
                        }
                    }
                });

            } catch (err) {
                console.error("Error rendering asset execution count chart:", err);
                loading.classList.add('hidden');
                error.textContent = 'Gagal memuat data frekuensi aset: ' + err.message;
                error.classList.remove('hidden');
                canvas.style.display = 'none';
            }
        }

        // --- NEW: Compounding Simulator Logic ---
        function calculateProjectionData(dataType) {
            const simBalanceInput = document.getElementById('simBalance');
            const simMonthlyTargetInput = document.getElementById('simMonthlyTarget');
            const simPeriodInput = document.getElementById('simPeriod');

            const startBalance = parseFloat(simBalanceInput.value);
            const monthlyTarget = parseFloat(simMonthlyTargetInput.value) / 100;
            const periodMonths = parseInt(simPeriodInput.value);

            const projectionLabels = [];
            const projectionData = [];

            if (isNaN(startBalance) || isNaN(monthlyTarget) || isNaN(periodMonths) || periodMonths <= 0) {
                return { projectionLabels, projectionData };
            }

            const sortedTrades = [...executedPlansData].filter(t => t.outcome !== 'Cancel' && t.outcome !== 'Tes').sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            let lastTradeDate = sortedTrades.length > 0 ? new Date(sortedTrades[sortedTrades.length - 1].timestamp) : new Date();
            let currentProjectedBalance = startBalance;
            let historicalInitialBalance = sortedTrades.length > 0 ? sortedTrades[0].balance : startBalance;

            for (let i = 1; i <= periodMonths; i++) {
                currentProjectedBalance *= (1 + monthlyTarget);
                const projectedDate = new Date(lastTradeDate);
                projectedDate.setMonth(projectedDate.getMonth() + i);
                
                projectionLabels.push(projectedDate.toLocaleString('id-ID', { day: 'numeric', month: 'short', year: 'numeric' }));
                
                if (dataType === 'balance') {
                    projectionData.push(currentProjectedBalance);
                } else if (dataType === 'percentage') {
                    const percentageChange = historicalInitialBalance > 0 ? ((currentProjectedBalance - historicalInitialBalance) / historicalInitialBalance) * 100 : 0;
                    projectionData.push(percentageChange);
                }
            }
            return { projectionLabels, projectionData };
        }
        
        function handleSimulatorInputChange() {
            // Save data to local storage whenever it changes
            saveSimulatorData();
            // This function triggers the re-rendering of the charts that need projection lines.
            // The chart rendering functions themselves will read the simulator inputs.
            if (chartSections.overallBalanceCumulativeStatisticsSection.hasRendered) {
                fetchAndRenderOverallBalanceCumulativeChart();
            }
            if (chartSections.overallPercentageCumulativeStatisticsSection.hasRendered) {
                fetchAndRenderOverallPercentageCumulativeChart();
            }
        }

        // --- PERBAIKAN STRUKTURAL: BLOK FUNGSI RINGKASAN DIPINDAHKAN KE SINI (LINGKUP GLOBAL) ---
        
        /**
         * Helper function to get the week number of a date.
         * @param {Date} d The date.
         * @returns {number} The week number.
         */
        function getWeekNumber(d) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return weekNo;
        }

        function calculateAndRenderDailySummary() {
            const summaryBody = document.getElementById('newDailySummaryBody');
            if (!summaryBody) return;

            const relevantTrades = executedPlansData
                .filter(trade => getTradeResult(trade).isValid && trade && trade.timestamp)
                .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            if (relevantTrades.length === 0) {
                summaryBody.innerHTML = `<tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data harian.</td></tr>`;
                return;
            }

            summaryBody.innerHTML = '';
            const dailyData = {};
            const firstTradeWithBalance = relevantTrades.find(t => typeof t.balance === 'number' && !isNaN(t.balance));
            const initialBalance = firstTradeWithBalance ? firstTradeWithBalance.balance : 0;

            relevantTrades.forEach(trade => {
                const tradeDate = new Date(trade.timestamp);
                if (isNaN(tradeDate.getTime())) return;
                const dayKey = `${tradeDate.getFullYear()}-${tradeDate.getMonth()}-${tradeDate.getDate()}`;
                
                if (!dailyData[dayKey]) {
                    dailyData[dayKey] = { tradeCount: 0, pips: 0, pl: 0, dayName: tradeDate.toLocaleDateString('id-ID', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) };
                }
                
                const { isWin } = getTradeResult(trade);
                const pointsForTrade = isWin ? getVisualPoints(parseFloat(trade.tpPips), trade.symbol).forCalc : -getVisualPoints(parseFloat(trade.slPips), trade.symbol).forCalc;
                const profitLossAmount = isWin ? parseFloat(trade.nettTP) : parseFloat(trade.nettSL);

                if (!isNaN(pointsForTrade)) dailyData[dayKey].pips += pointsForTrade;
                if (!isNaN(profitLossAmount)) dailyData[dayKey].pl += profitLossAmount;
                dailyData[dayKey].tradeCount++;
            });

            const sortedDayKeys = Object.keys(dailyData).sort((a, b) => new Date(a.split('-').join('/')) - new Date(b.split('-').join('/')));
            let cumulativeTradeCount = 0, cumulativePips = 0, cumulativeBalance = initialBalance;

            for (const dayKey of sortedDayKeys) {
                const day = dailyData[dayKey];
                cumulativeTradeCount += day.tradeCount;
                cumulativePips += day.pips;
                cumulativeBalance += day.pl;
                
                const cumulativePercentage = initialBalance > 0 ? ((cumulativeBalance - initialBalance) / initialBalance) * 100 : 0;
                const percentageClass = cumulativePercentage >= 0 ? 'positive-value' : 'negative-value';
                const pipsClass = cumulativePips >= 0 ? 'positive-value' : 'negative-value';
                const balanceClass = cumulativeBalance >= initialBalance ? 'positive-value' : 'negative-value';

                summaryBody.insertAdjacentHTML('beforeend', `
                    <tr>
                        <td class="py-3 px-4 text-center text-neutral-value">${day.dayName}</td>
                        <td class="py-3 px-4 text-center ${percentageClass}">${formatNumber(cumulativePercentage, 2)}%</td>
                        <td class="py-3 px-4 text-center ${pipsClass}">${formatNumber(cumulativePips, 0)}</td>
                        <td class="py-3 px-4 text-center text-neutral-value">${cumulativeTradeCount}</td>
                        <td class="py-3 px-4 text-center ${balanceClass}">${formatCurrency(cumulativeBalance, 'USD')}</td>
                    </tr>
                `);
            }
        }

        function calculateAndRenderWeeklySummary() {
            const summaryBody = document.getElementById('newWeeklySummaryBody');
            if (!summaryBody) return;

            const relevantTrades = executedPlansData
                .filter(trade => getTradeResult(trade).isValid && trade && trade.timestamp)
                .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            if (relevantTrades.length === 0) {
                summaryBody.innerHTML = `<tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data mingguan.</td></tr>`;
                return;
            }

            summaryBody.innerHTML = '';
            const weeklyData = {};
            const firstTradeWithBalance = relevantTrades.find(t => typeof t.balance === 'number' && !isNaN(t.balance));
            const initialBalance = firstTradeWithBalance ? firstTradeWithBalance.balance : 0;

            relevantTrades.forEach(trade => {
                const tradeDate = new Date(trade.timestamp);
                if (isNaN(tradeDate.getTime())) return;
                const weekKey = `${tradeDate.getFullYear()}-W${getWeekNumber(tradeDate)}`;
                
                if (!weeklyData[weekKey]) {
                    weeklyData[weekKey] = { tradeCount: 0, pips: 0, pl: 0, weekName: `Minggu ${getWeekNumber(tradeDate)}, ${tradeDate.getFullYear()}` };
                }
                
                const { isWin } = getTradeResult(trade);
                const pointsForTrade = isWin ? getVisualPoints(parseFloat(trade.tpPips), trade.symbol).forCalc : -getVisualPoints(parseFloat(trade.slPips), trade.symbol).forCalc;
                const profitLossAmount = isWin ? parseFloat(trade.nettTP) : parseFloat(trade.nettSL);

                if (!isNaN(pointsForTrade)) weeklyData[weekKey].pips += pointsForTrade;
                if (!isNaN(profitLossAmount)) weeklyData[weekKey].pl += profitLossAmount;
                weeklyData[weekKey].tradeCount++;
            });

            const sortedWeekKeys = Object.keys(weeklyData).sort();
            let cumulativeTradeCount = 0, cumulativePips = 0, cumulativeBalance = initialBalance;

            for (const weekKey of sortedWeekKeys) {
                const week = weeklyData[weekKey];
                cumulativeTradeCount += week.tradeCount;
                cumulativePips += week.pips;
                cumulativeBalance += week.pl;
                
                const cumulativePercentage = initialBalance > 0 ? ((cumulativeBalance - initialBalance) / initialBalance) * 100 : 0;
                const percentageClass = cumulativePercentage >= 0 ? 'positive-value' : 'negative-value';
                const pipsClass = cumulativePips >= 0 ? 'positive-value' : 'negative-value';
                const balanceClass = cumulativeBalance >= initialBalance ? 'positive-value' : 'negative-value';

                summaryBody.insertAdjacentHTML('beforeend', `
                    <tr>
                        <td class="py-3 px-4 text-center text-neutral-value">${week.weekName}</td>
                        <td class="py-3 px-4 text-center ${percentageClass}">${formatNumber(cumulativePercentage, 2)}%</td>
                        <td class="py-3 px-4 text-center ${pipsClass}">${formatNumber(cumulativePips, 0)}</td>
                        <td class="py-3 px-4 text-center text-neutral-value">${cumulativeTradeCount}</td>
                        <td class="py-3 px-4 text-center ${balanceClass}">${formatCurrency(cumulativeBalance, 'USD')}</td>
                    </tr>
                `);
            }
        }

        function calculateAndRenderNewMonthlySummary() {
            const summaryBody = document.getElementById('newMonthlySummaryBody');
            if (!summaryBody) return;

            const relevantTrades = executedPlansData
                .filter(trade => getTradeResult(trade).isValid && trade && trade.timestamp)
                .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            if (relevantTrades.length === 0) {
                summaryBody.innerHTML = `<tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data trading yang selesai untuk ditampilkan.</td></tr>`;
                return;
            }

            summaryBody.innerHTML = '';
            const monthlyData = {};
            const firstTradeWithBalance = relevantTrades.find(t => typeof t.balance === 'number' && !isNaN(t.balance));
            const initialBalance = firstTradeWithBalance ? firstTradeWithBalance.balance : 0;

            relevantTrades.forEach(trade => {
                const tradeDate = new Date(trade.timestamp);
                if (isNaN(tradeDate.getTime())) return;
                const monthKey = `${tradeDate.getFullYear()}-${tradeDate.getMonth()}`;
                
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = { tradeCount: 0, pips: 0, pl: 0, monthName: tradeDate.toLocaleString('id-ID', { month: 'long', year: 'numeric' }) };
                }
                
                const { isWin } = getTradeResult(trade);
                const pointsForTrade = isWin ? getVisualPoints(parseFloat(trade.tpPips), trade.symbol).forCalc : -getVisualPoints(parseFloat(trade.slPips), trade.symbol).forCalc;
                const profitLossAmount = isWin ? parseFloat(trade.nettTP) : parseFloat(trade.nettSL);

                if (!isNaN(pointsForTrade)) monthlyData[monthKey].pips += pointsForTrade;
                if (!isNaN(profitLossAmount)) monthlyData[monthKey].pl += profitLossAmount;
                monthlyData[monthKey].tradeCount++;
            });

            const sortedMonthKeys = Object.keys(monthlyData).sort((a, b) => {
                const [yearA, monthA] = a.split('-');
                const [yearB, monthB] = b.split('-');
                return new Date(yearA, monthA) - new Date(yearB, monthB);
            });
            
            let cumulativeTradeCount = 0, cumulativePips = 0, cumulativeBalance = initialBalance;

            for (const monthKey of sortedMonthKeys) {
                const month = monthlyData[monthKey];
                cumulativeTradeCount += month.tradeCount;
                cumulativePips += month.pips;
                cumulativeBalance += month.pl; 
                
                const cumulativePercentage = initialBalance > 0 ? ((cumulativeBalance - initialBalance) / initialBalance) * 100 : 0;
                const percentageClass = cumulativePercentage >= 0 ? 'positive-value' : 'negative-value';
                const pipsClass = cumulativePips >= 0 ? 'positive-value' : 'negative-value';
                const balanceClass = cumulativeBalance >= initialBalance ? 'positive-value' : 'negative-value';

                summaryBody.insertAdjacentHTML('beforeend', `
                    <tr>
                        <td class="py-3 px-4 text-center text-neutral-value">${month.monthName}</td>
                        <td class="py-3 px-4 text-center ${percentageClass}">${formatNumber(cumulativePercentage, 2)}%</td>
                        <td class="py-3 px-4 text-center ${pipsClass}">${formatNumber(cumulativePips, 0)}</td>
                        <td class="py-3 px-4 text-center text-neutral-value">${cumulativeTradeCount}</td>
                        <td class="py-3 px-4 text-center ${balanceClass}">${formatCurrency(cumulativeBalance, 'USD')}</td>
                    </tr>
                `);
            }
        }

        function calculateAndRenderYearlySummary() {
            const summaryBody = document.getElementById('newYearlySummaryBody');
            if (!summaryBody) return;

            const relevantTrades = executedPlansData
                .filter(trade => getTradeResult(trade).isValid && trade && trade.timestamp)
                .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            if (relevantTrades.length === 0) {
                summaryBody.innerHTML = `<tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data tahunan.</td></tr>`;
                return;
            }

            summaryBody.innerHTML = '';
            const yearlyData = {};
            const firstTradeWithBalance = relevantTrades.find(t => typeof t.balance === 'number' && !isNaN(t.balance));
            const initialBalance = firstTradeWithBalance ? firstTradeWithBalance.balance : 0;

            relevantTrades.forEach(trade => {
                const tradeDate = new Date(trade.timestamp);
                if (isNaN(tradeDate.getTime())) return;
                const yearKey = `${tradeDate.getFullYear()}`;
                
                if (!yearlyData[yearKey]) {
                    yearlyData[yearKey] = { tradeCount: 0, pips: 0, pl: 0, yearName: yearKey };
                }
                
                const { isWin } = getTradeResult(trade);
                const pointsForTrade = isWin ? getVisualPoints(parseFloat(trade.tpPips), trade.symbol).forCalc : -getVisualPoints(parseFloat(trade.slPips), trade.symbol).forCalc;
                const profitLossAmount = isWin ? parseFloat(trade.nettTP) : parseFloat(trade.nettSL);

                if (!isNaN(pointsForTrade)) yearlyData[yearKey].pips += pointsForTrade;
                if (!isNaN(profitLossAmount)) yearlyData[yearKey].pl += profitLossAmount;
                yearlyData[yearKey].tradeCount++;
            });

            const sortedYearKeys = Object.keys(yearlyData).sort();
            let cumulativeTradeCount = 0, cumulativePips = 0, cumulativeBalance = initialBalance;

            for (const yearKey of sortedYearKeys) {
                const year = yearlyData[yearKey];
                cumulativeTradeCount += year.tradeCount;
                cumulativePips += year.pips;
                cumulativeBalance += year.pl;
                
                const cumulativePercentage = initialBalance > 0 ? ((cumulativeBalance - initialBalance) / initialBalance) * 100 : 0;
                const percentageClass = cumulativePercentage >= 0 ? 'positive-value' : 'negative-value';
                const pipsClass = cumulativePips >= 0 ? 'positive-value' : 'negative-value';
                const balanceClass = cumulativeBalance >= initialBalance ? 'positive-value' : 'negative-value';

                summaryBody.insertAdjacentHTML('beforeend', `
                    <tr>
                        <td class="py-3 px-4 text-center text-neutral-value">${year.yearName}</td>
                        <td class="py-3 px-4 text-center ${percentageClass}">${formatNumber(cumulativePercentage, 2)}%</td>
                        <td class="py-3 px-4 text-center ${pipsClass}">${formatNumber(cumulativePips, 0)}</td>
                        <td class="py-3 px-4 text-center text-neutral-value">${cumulativeTradeCount}</td>
                        <td class="py-3 px-4 text-center ${balanceClass}">${formatCurrency(cumulativeBalance, 'USD')}</td>
                    </tr>
                `);
            }
        }

        /**
         * FUNGSI BANTUAN BARU: Menggabungkan data baru, menyimpan, dan merender ulang seluruh UI.
         * Fungsi ini menjadi pusat pembaruan data untuk memastikan konsistensi.
         * @param {Array} newCalculated - Array rencana baru yang akan ditambahkan.
         * @param {Array} newRunning - Array rencana aktif yang akan ditambahkan.
         * @param {Array} newExecuted - Array rencana selesai yang akan ditambahkan.
         */
        function updateAllDataAndRenderUI(newCalculated, newRunning, newExecuted) {
            // Gabungkan data baru yang diimpor dengan data yang sudah ada di aplikasi
            calculatedPlansData.push(...newCalculated);
            runningPlansData.push(...newRunning);
            executedPlansData.push(...newExecuted);

            // Pastikan data yang telah selesai selalu diurutkan berdasarkan waktu untuk kalkulasi yang akurat
            executedPlansData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            // Simpan data gabungan terbaru ke local storage sebagai cadangan
            saveDataToLocalStorage();

            // Render ulang semua tabel untuk menampilkan data gabungan
            renderCalculatedPlans();
            renderRunningPlans();
            renderExecutedPlans();

            // Hitung ulang semua statistik dan ringkasan dari data gabungan
            calculateSummaryStatistics();
            updateRiskRewardStatistics();
            calculateAndRenderDailySummary();
            calculateAndRenderWeeklySummary();
            calculateAndRenderNewMonthlySummary();
            calculateAndRenderYearlySummary();

            console.log("UI dan semua data telah diperbarui secara manual setelah impor.");
        }

        /**
         * FUNGSI BANTUAN BARU: Mem-parsing string tanggal dalam berbagai format umum.
         * @param {string} dateString - String tanggal yang akan di-parsing.
         * @returns {Date|null} Objek Date yang valid atau null jika gagal.
         */
        function parseDateRobust(dateString) {
            if (!dateString || typeof dateString !== 'string') return null;

            // 1. Coba format ISO (paling andal, format default dari unduhan)
            let date = new Date(dateString);
            if (!isNaN(date.getTime())) return date;

            // 2. Coba format DD/MM/YYYY atau DD-MM-YYYY dengan waktu opsional
            const parts = dateString.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4}).*?(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?/);
            if (parts) {
                const day = parseInt(parts[1], 10);
                const month = parseInt(parts[2], 10) - 1; // Bulan di JS dimulai dari 0
                const year = parseInt(parts[3], 10);
                const hour = parseInt(parts[4] || '0', 10);
                const min = parseInt(parts[5] || '0', 10);
                const sec = parseInt(parts[6] || '0', 10);
                date = new Date(year, month, day, hour, min, sec);
                if (!isNaN(date.getTime())) return date;
            }
            
            // Jika semua format gagal, kembalikan null
            return null;
        }

        /**
         * FUNGSI BANTUAN BARU: Menganalisis hasil trading secara terpusat.
         * @param {Object} trade - Objek data trading.
         * @returns {{isWin: boolean, isLoss: boolean, isValid: boolean}}
         */
        function getTradeResult(trade) {
            if (!trade || !trade.outcome) return { isWin: false, isLoss: false, isValid: false };
            const outcome = (trade.outcome || '').toLowerCase();
            const isWin = outcome.includes('profit') || outcome.includes('tp');
            const isLoss = outcome.includes('loss') || outcome.includes('sl');
            return {
                isWin: isWin,
                isLoss: isLoss,
                isValid: isWin || isLoss // Trade valid jika merupakan profit atau loss
            };
        }

        // --- AKHIR DARI BLOK FUNGSI YANG DIPINDAHKAN ---

        function downloadDailySummaryAsExcel(filename) {
            const summaryBody = document.getElementById('newDailySummaryBody');
            if (!summaryBody || summaryBody.rows.length === 0 || (summaryBody.rows.length === 1 && summaryBody.rows[0].cells.length <= 1)) {
                showMessageBox('Informasi', 'Tidak ada data ringkasan harian untuk diunduh.', false);
                return;
            }
            const headers = ["Tanggal", "Presentase Kumulatif (%)", "Total Pips Kumulatif", "Total Trade", "Saldo Akhir Kumulatif ($)"];
            let csvContent = headers.join(',') + '\r\n';
            for (const row of summaryBody.rows) {
                const rowData = Array.from(row.cells).map(cell => `"${cell.textContent.replace(/[%$,]/g, '').trim()}"`);
                csvContent += rowData.join(',') + '\r\n';
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }

        function downloadWeeklySummaryAsExcel(filename) {
            const summaryBody = document.getElementById('newWeeklySummaryBody');
            if (!summaryBody || summaryBody.rows.length === 0 || (summaryBody.rows.length === 1 && summaryBody.rows[0].cells.length <= 1)) {
                showMessageBox('Informasi', 'Tidak ada data ringkasan mingguan untuk diunduh.', false);
                return;
            }
            const headers = ["Minggu", "Presentase Kumulatif (%)", "Total Pips Kumulatif", "Total Trade", "Saldo Akhir Kumulatif ($)"];
            let csvContent = headers.join(',') + '\r\n';
            for (const row of summaryBody.rows) {
                const rowData = Array.from(row.cells).map(cell => `"${cell.textContent.replace(/[%$,]/g, '').trim()}"`);
                csvContent += rowData.join(',') + '\r\n';
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }

        function downloadYearlySummaryAsExcel(filename) {
            const summaryBody = document.getElementById('newYearlySummaryBody');
            if (!summaryBody || summaryBody.rows.length === 0 || (summaryBody.rows.length === 1 && summaryBody.rows[0].cells.length <= 1)) {
                showMessageBox('Informasi', 'Tidak ada data ringkasan tahunan untuk diunduh.', false);
                return;
            }
            const headers = ["Tahun", "Presentase Kumulatif (%)", "Total Pips Kumulatif", "Total Trade", "Saldo Akhir Kumulatif ($)"];
            let csvContent = headers.join(',') + '\r\n';
            for (const row of summaryBody.rows) {
                const rowData = Array.from(row.cells).map(cell => `"${cell.textContent.replace(/[%$,]/g, '').trim()}"`);
                csvContent += rowData.join(',') + '\r\n';
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }

        function downloadNewMonthlySummaryAsExcel(filename) {
            const summaryBody = document.getElementById('newMonthlySummaryBody');
            if (!summaryBody || summaryBody.rows.length === 0 || (summaryBody.rows.length === 1 && summaryBody.rows[0].cells.length <= 1)) {
                showMessageBox('Informasi', 'Tidak ada data ringkasan bulanan untuk diunduh.', false);
                return;
            }

            const headers = ["Bulan", "Presentase Kumulatif (%)", "Total Pips Kumulatif", "Total Trade", "Saldo Akhir Kumulatif ($)"];
            let csvContent = headers.join(',') + '\r\n';

            for (const row of summaryBody.rows) {
                const rowData = [];
                for (const cell of row.cells) {
                    let cellText = cell.textContent.replace(/[%$]/g, '').replace(/,/g, '').trim();
                    if (cellText.includes(',')) {
                        cellText = `"${cellText}"`;
                    }
                    rowData.push(cellText);
                }
                csvContent += rowData.join(',') + '\r\n';
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }


        // --- CORE CALCULATOR LOGIC ---
        const getAssetData = (symbol) => assetValues[symbol] || { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 };

        // Updated calculatePipsPoints to correctly handle different asset types
        function calculatePipsPoints(priceDiff, symbol) {
            const assetData = getAssetData(symbol);
            if (!assetData) return 0; // Handle unknown symbol

            if (assetData.type.includes('forex')) {
                // For 5-decimal forex pairs (e.g., EUR/USD), 1 pip = 0.0001 (multiplier 10000)
                // For 3-decimal forex pairs (e.g., USD/JPY), 1 pip = 0.01 (multiplier 100)
                const pipMultiplier = (assetData.decimals === 5) ? 10000 : 100;
                return priceDiff * pipMultiplier;
            }
            // For other assets (indices, commodities, crypto), priceDiff is directly the "points"
            return priceDiff;
        }

        /**
         * FUNGSI BANTUAN BARU: Mengonversi data dari <tbody> tabel HTML menjadi format Array of Arrays.
         * @param {HTMLElement} tableBodyElement - Elemen <tbody> dari tabel yang akan dibaca.
         * @param {Array<string>} headers - Array berisi string header untuk baris pertama.
         * @returns {Array<Array<string>>} Data tabel dalam format AoA.
         */
        function tableToAoA(tableBodyElement, headers) {
            const data = [headers]; // Mulai dengan baris header
            if (tableBodyElement && tableBodyElement.rows.length > 0) {
                // Cek jika baris pertama adalah pesan "tidak ada data"
                if (tableBodyElement.rows[0].cells.length <= 1) {
                    return data; // Kembalikan hanya header jika tidak ada data
                }
                for (const row of tableBodyElement.rows) {
                    const rowData = Array.from(row.cells).map(cell => {
                        // Bersihkan teks dari karakter mata uang, persen, dan koma ribuan
                        return cell.textContent.replace(/[$,%]/g, '').trim();
                    });
                    data.push(rowData);
                }
            }
            return data;
        }

        function calculateRow(rowId) {
            const rowElement = document.getElementById(`inputRow-${rowId}`); if (!rowElement) return null;
            const tradeType = rowElement.querySelector(`#buyBtn-${rowId}`).classList.contains('active') ? 'BUY' : (rowElement.querySelector(`#sellBtn-${rowId}`).classList.contains('active') ? 'SELL' : null);
            const inputs = ['symbol', 'balance', 'riskPercent', 'priceNow', 'openPrice', 'slPrice', 'tpPrice', 'note'].reduce((acc, id) => ({ ...acc, [id]: rowElement.querySelector(`#${id}-${rowId}`) }), {});
            
            // Get values directly from input elements
            const selectedSymbol = inputs.symbol.value;
            const balance = parseFloat(inputs.balance.value);
            const riskPercent = parseFloat(inputs.riskPercent.value);
            const priceNow = parseFloat(inputs.priceNow.value);
            const openPrice = parseFloat(inputs.openPrice.value);
            const slPrice = parseFloat(inputs.slPrice.value);
            const tpPrice = parseFloat(inputs.tpPrice.value);
            const note = inputs.note.value.trim();

            const riskLimitNote = rowElement.querySelector(`#riskLimitNote-${rowId}`);
            let isValid = true;
            
            // Clear previous messages and error highlights
            riskLimitNote.classList.add('hidden');
            Object.values(inputs).forEach(input => input.classList.remove('border-red-500'));

            // Validate inputs
            if (!selectedSymbol || selectedSymbol.trim() === '') { inputs.symbol.classList.add('border-red-500'); isValid = false; }
            if (!tradeType) isValid = false;
            if (isNaN(balance) || balance <= 0) { inputs.balance.classList.add('border-red-500'); isValid = false; }
            if (isNaN(riskPercent) || riskPercent <= 0) { inputs.riskPercent.classList.add('border-red-500'); isValid = false; }
            if (isNaN(priceNow) || priceNow < 0) { inputs.priceNow.classList.add('border-red-500'); isValid = false; }
            if (isNaN(openPrice) || openPrice < 0) { inputs.openPrice.classList.add('border-red-500'); isValid = false; }
            if (isNaN(slPrice) || slPrice < 0) { inputs.slPrice.classList.add('border-red-500'); isValid = false; }
            if (isNaN(tpPrice) || tpPrice < 0) { inputs.tpPrice.classList.add('border-red-500'); isValid = false; }

            const cappedRiskPercent = riskPercent > MAX_RISK_PER_TRADE ? MAX_RISK_PER_TRADE : riskPercent;
            if (riskPercent > MAX_RISK_PER_TRADE) { riskLimitNote.textContent = `Risiko maksimal adalah ${MAX_RISK_PER_TRADE}%`; riskLimitNote.classList.remove('hidden'); isValid = false; }

            if (!isValid) return { error: true }; // Return early if basic validation fails

            const assetData = getAssetData(selectedSymbol);
            const { minLotIncrement } = assetData;
            const isCommodity = assetData.type === 'commodity';

            const [priceDiffSL, priceDiffTP, priceDiffPending] = tradeType === 'BUY' ? [openPrice - slPrice, tpPrice - openPrice, priceNow - openPrice] : [slPrice - openPrice, openPrice - tpPrice, openPrice - priceNow];
            
            const slPipsPrecise = calculatePipsPoints(priceDiffSL, selectedSymbol);
            const tpPipsPrecise = calculatePipsPoints(priceDiffTP, selectedSymbol);
            const pendingPipsPrecise = calculatePipsPoints(priceDiffPending, selectedSymbol);

            let rrPips, finalLotSize, finalNettSL, finalNettTP;
            const riskAmount = balance * (cappedRiskPercent / 100);

            if (isCommodity) {
                // --- PERBAIKAN LOGIKA KHUSUS KOMODITAS ---

                // 1. Kalkulasi R:R Pips (disesuaikan)
                const slPipsForRatio = slPipsPrecise / 10;
                const tpPipsForRatio = tpPipsPrecise / 10;
                rrPips = slPipsForRatio > 0 ? tpPipsForRatio / slPipsForRatio : 0;

                // 2. Kalkulasi Lot/Units (akurat)
                const rawLotSize = (slPipsPrecise > 0 && assetData.contractSize > 0) ? riskAmount / (slPipsPrecise * assetData.contractSize) : 0;
                finalLotSize = Math.floor(rawLotSize / minLotIncrement) * minLotIncrement;
                if (finalLotSize === 0 && rawLotSize > 0) {
                    finalLotSize = minLotIncrement;
                }

                // 3. Kalkulasi Nett SL & Nett TP (akurat)
                finalNettSL = -(finalLotSize * slPipsPrecise * assetData.contractSize);
                finalNettTP = finalLotSize * tpPipsPrecise * assetData.contractSize;

            } else {
                // --- LOGIKA LAMA UNTUK ASET SELAIN KOMODITAS ---
                const slPointsForCalc = getVisualPoints(slPipsPrecise, selectedSymbol).forCalc;
                const tpPointsForCalc = getVisualPoints(tpPipsPrecise, selectedSymbol).forCalc;
                const pipPointValuePerStandardLot = assetData.pipValue;

                rrPips = slPointsForCalc > 0 ? tpPointsForCalc / slPointsForCalc : 0;

                let calculatedLotSize = (slPointsForCalc > 0 && pipPointValuePerStandardLot > 0) ?
                                        Math.floor((riskAmount / (slPointsForCalc * pipPointValuePerStandardLot)) / minLotIncrement) * minLotIncrement :
                                        0;
                finalLotSize = calculatedLotSize;
                if (calculatedLotSize === 0 && riskAmount > 0 && slPointsForCalc > 0 && pipPointValuePerStandardLot > 0) {
                    finalLotSize = minLotIncrement;
                }
                finalNettSL = -(finalLotSize * slPointsForCalc * pipPointValuePerStandardLot);
                finalNettTP = (finalLotSize * tpPointsForCalc * pipPointValuePerStandardLot);
            }
            
            const actualRiskPercent = (balance > 0) ? (Math.abs(finalNettSL) / balance) * 100 : 0;
            const [percentageSL, percentageTP] = balance > 0 ? [(Math.abs(finalNettSL) / balance) * 100, (finalNettTP / balance) * 100] : [0, 0];

            return {
                rowId, symbol: selectedSymbol, tradeType, balance, entryTime: new Date().toISOString(),
                openPrice, slPrice, tpPrice, priceNow,
                pendingPips: pendingPipsPrecise,
                slPips: slPipsPrecise,
                tpPips: tpPipsPrecise,
                rrPips, rrPercentage: { sl: percentageSL, tp: percentageTP },
                lotSize: finalLotSize, nettSL: finalNettSL, nettTP: finalNettTP,
                error: false, assetData, riskPercent: actualRiskPercent, note
            };
        }

        function displayCalculationDetails(result) {
            calculationDetailsContainer.innerHTML = '';
            // This section is now hidden by default and might be used for single-plan details if needed in the future
            // For now, it won't display anything unless explicitly made visible and populated.
        }

        function calculateAllRows() {
            console.log("Calculating all rows...");
            calculatedPlansData = []; // Clear previous calculated plans
            const allInputRows = document.querySelectorAll('.input-row');
            if (allInputRows.length === 0) {
                renderCalculatedPlans(); // Render empty table
                return;
            }
            allInputRows.forEach(row => {
                const rowId = row.id.split('-')[1];
                const result = calculateRow(rowId);
                if (result && !result.error) { // Check for error flag
                    calculatedPlansData.push(result);
                    if (db && userId !== 'anonymous') {
                        saveCalculatedPlan(userId, result);
                    }
                }
            });
            renderCalculatedPlans();
            saveDataToLocalStorage();
            console.log("Calculation complete. Calculated Plans:", calculatedPlansData.length);
        }

        function renderPlans(plans, bodyElement, colspan, emptyMessage, isCalculated = false, isRunning = false) {
            bodyElement.innerHTML = '';
            
            const isExecutedPlanTable = bodyElement.id === 'executedPlansBody';

            if (plans.length === 0) {
                bodyElement.innerHTML = `<tr><td colspan="${colspan}" class="py-4 text-center text-gray-500">${emptyMessage}</td></tr>`;
                return;
            }

            plans.forEach(plan => {
                const { symbol, tradeType, balance, entryTime, openPrice, slPrice, tpPrice, pendingPips, slPips, tpPips, rrPips, rrPercentage, lotSize, nettSL, nettTP, note, assetData, outcome, timestamp, rowId } = plan;
                const currentAssetData = assetData || getAssetData(symbol);

                const slPipsDisplay = getVisualPoints(slPips, symbol).display;
                const tpPipsDisplay = getVisualPoints(tpPips, symbol).display;
                const pendingPipsDisplay = getVisualPoints(pendingPips, symbol).display;
                
                const slPipsClass = parseFloat(slPipsDisplay) === 0 ? 'negative-value' : 'neutral-value';
                const tpPipsClass = parseFloat(tpPipsDisplay) > 0 ? 'positive-value' : 'negative-value';
                const pendingPipsClass = parseFloat(pendingPipsDisplay) >= 0 ? 'positive-value' : 'negative-value';
                const lotSizeClass = parseFloat(lotSize) === 0 ? 'negative-value' : 'neutral-value';
                const nettSLClass = 'negative-value';
                const nettTPClass = nettTP >= 0 ? 'positive-value' : 'negative-value';
                const rrPipsFormatted = rrPips > 0 ? '1:' + formatNumber(rrPips, 1, false) : 'N/A';
                const rrPipsClass = rrPips > 0 ? 'positive-value' : 'neutral-value';
                
                let rrPercentageHtml = '<span class="neutral-value">N/A</span>';
                if (rrPercentage && typeof rrPercentage.sl !== 'undefined' && typeof rrPercentage.tp !== 'undefined') {
                    const slFormatted = `-${formatNumber(rrPercentage.sl, 2)}%`;
                    const tpFormatted = `${formatNumber(rrPercentage.tp, 2)}%`;
                    const tpClass = rrPercentage.tp >= 0 ? 'positive-value' : 'negative-value';
                    rrPercentageHtml = `<span class="negative-value">${slFormatted}</span> : <span class="${tpClass}">${tpFormatted}</span>`;
                }

                const entryTimeFormatted = new Date(entryTime).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const exitTimeFormatted = timestamp ? new Date(timestamp).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : 'N/A';
                const outcomeText = outcome === 'Cancel' ? 'Dibatalkan' : 
                                    outcome === 'Tes' ? 'Tes Selesai' :
                                    (outcome === 'Stop Loss' ? 'Selesai: Stop Loss' : 
                                    (outcome === 'Take Profit' ? 'Selesai: Take Profit' : 'Running'));

                let actionButtonsHtml = '';
                if (isCalculated) {
                    actionButtonsHtml = `<button type="button" class="action-button-small" data-from-section="calculated" data-outcome="Running" data-row-id="${rowId}">Set Running</button>`;
                } else if (isRunning) {
                    actionButtonsHtml = `
                        <button type="button" class="action-button-small" data-from-section="running" data-outcome="Tes" data-row-id="${rowId}">TES</button>
                        <button type="button" class="action-button-small" data-from-section="running" data-outcome="Cancel" data-row-id="${rowId}">BATAL</button>
                        <button type="button" class="action-button-small" data-from-section="running" data-outcome="Stop Loss" data-row-id="${rowId}">STOP LOSS</button>
                        <button type="button" class="action-button-small" data-from-section="running" data-outcome="Take Profit" data-row-id="${rowId}">TAKE PROFIT</button>
                        <button type="button" class="action-button-small" data-from-section="running" data-outcome="Edit" data-row-id="${rowId}">EDIT</button>
                    `;
                }

                bodyElement.insertAdjacentHTML('beforeend', `
                    <tr class="hover:bg-gray-50">
                        <td class="py-3 px-4 text-neutral-value">${symbol || 'N/A'}</td><td class="py-3 px-4 font-semibold ${tradeType === 'BUY' ? 'positive-value' : 'negative-value'}">${tradeType || 'N/A'}</td>
                        <td class="py-3 px-4 text-neutral-value">${formatCurrency(balance, 'USD')}</td><td class="py-3 px-4 text-neutral-value">${entryTimeFormatted}</td>
                        <td class="py-3 px-4 text-neutral-value">${formatNumber(openPrice, currentAssetData.decimals, false)}</td><td class="py-3 px-4 text-neutral-value">${formatNumber(slPrice, currentAssetData.decimals, false)}</td>
                        <td class="py-3 px-4 text-neutral-value">${formatNumber(tpPrice, currentAssetData.decimals, false)}</td>
                        <td class="py-3 px-4 ${pendingPipsClass}">${pendingPipsDisplay}</td>
                        <td class="py-3 px-4 ${slPipsClass}">${slPipsDisplay}</td>
                        <td class="py-3 px-4 ${tpPipsClass}">${tpPipsDisplay}</td>
                        <td class="py-3 px-4 ${rrPipsClass}">${rrPipsFormatted}</td>
                        <td class="py-3 px-4">${rrPercentageHtml}</td>
                        <td class="py-3 px-4 ${lotSizeClass}">${formatNumber(lotSize, 2)}</td><td class="py-3 px-4 ${nettSLClass}">${formatCurrency(nettSL, 'USD')}</td>
                        <td class="py-3 px-4 ${nettTPClass}">${formatCurrency(nettTP, 'USD')}</td><td class="py-3 px-4 text-neutral-value">${note || '-'}</td>
                        ${(isCalculated || isRunning) ? `<td class="py-3 px-4 text-center action-buttons-cell">${actionButtonsHtml}</td>` : `<td class="py-3 px-4 text-center"><span>${outcomeText}</span></td><td class="py-3 px-4 text-neutral-value">${exitTimeFormatted}</td>`}
                    </tr>
                `);
            });

            // --- INI BAGIAN PERBAIKAN ---
            // Event listener sekarang dipasang dengan benar untuk memanggil fungsi yang sudah ada.
            bodyElement.querySelectorAll('.action-button-small').forEach(button => {
                button.addEventListener('click', (event) => {
                    const { rowId, outcome, fromSection } = event.target.dataset;
                    if (fromSection === 'calculated') {
                        setRunning(rowId);
                    } else if (fromSection === 'running') {
                        if (outcome === 'Edit') {
                            editRunningPlan(rowId);
                        } else {
                            // Memanggil fungsi completeTrade yang sudah ada, bukan mendefinisikan yang baru.
                            completeTrade(rowId, outcome, fromSection);
                        }
                    }
                });
            });
        }

        function renderCalculatedPlans() {
            console.log("Rendering calculated plans. Data length:", calculatedPlansData.length);
            renderPlans(calculatedPlansData, calculatedPlansBody, 17, 'Belum ada rencana trading baru.', true, false); // Pass true for isCalculated
        }

        function renderRunningPlans() {
            console.log("Rendering running plans. Data length:", runningPlansData.length);
            renderPlans(runningPlansData, runningPlansBody, 17, 'Belum ada rencana trading aktif.', false, true); // Pass true for isRunning
            updateActivePlansSummary();
        }

        async function renderExecutedPlans() {
            console.log("Rendering executed plans. Data length:", executedPlansData.length);
            renderPlans(executedPlansData, executedPlansBody, 18, 'Belum ada rencana trading yang selesai.');
            updateRiskRewardStatistics();
        }

        /**
         * FUNGSI BANTUAN BARU: Mengatur skala grafik agar responsif.
         * @param {Array} labels - Daftar semua label untuk sumbu-X.
         * @param {string} yAxisTitle - Judul untuk sumbu-Y.
         * @param {Function} yTickCallback - Fungsi untuk memformat label sumbu-Y.
         * @param {boolean} yBeginAtZero - Apakah sumbu-Y harus dimulai dari nol.
         * @returns {Object} Konfigurasi skala untuk Chart.js.
         */
        function getResponsiveChartScales(labels, yAxisTitle, yTickCallback, yBeginAtZero = false) {
            const isMobile = window.innerWidth <= 768;
            const totalLabels = labels.length;

            // Tentukan indeks yang akan ditampilkan di mobile
            const indicesToShow = new Set();
            if (totalLabels > 0) {
                indicesToShow.add(0); // Selalu tampilkan yang pertama
                indicesToShow.add(Math.floor((totalLabels - 1) / 2)); // Tampilkan yang tengah
                indicesToShow.add(totalLabels - 1); // Selalu tampilkan yang terakhir
            }

            return {
                x: {
                    title: {
                        display: true,
                        text: 'Tanggal & Waktu Trade',
                        color: '#555',
                        font: { family: 'Inter', size: 8, weight: 'bold' }
                    },
                    ticks: {
                        color: '#555',
                        font: { family: 'Inter', size: 7 },
                        callback: function(value, index, ticks) {
                            // Di mobile, hanya tampilkan label pada indeks yang telah ditentukan
                            if (isMobile && totalLabels > 3) { // Terapkan hanya jika ada lebih dari 3 data
                                if (indicesToShow.has(index)) {
                                    // Mengambil label asli dari array `labels`
                                    return labels[index];
                                }
                                return null; // Sembunyikan label lainnya
                            }
                            // Di desktop, tampilkan semua label
                            return labels[index];
                        },
                        autoSkip: false, // Wajib untuk memastikan callback kita berjalan untuk semua label
                    }
                },
                y: {
                    beginAtZero: yBeginAtZero,
                    title: {
                        display: true,
                        text: yAxisTitle,
                        color: '#555',
                        font: { family: 'Inter', size: 8, weight: 'bold' }
                    },
                    ticks: {
                        callback: yTickCallback,
                        color: '#555',
                        font: { family: 'Inter', size: 7 }
                    }
                }
            };
        }

        async function completeTrade(rowId, outcome, fromSection) {
            console.log(`Completing trade for rowId: ${rowId} with outcome: ${outcome} from section: ${fromSection}`);
            let planToExecute;
            if (fromSection === 'calculated') {
                const index = calculatedPlansData.findIndex(plan => plan.rowId === rowId);
                if (index !== -1) {
                    planToExecute = calculatedPlansData.splice(index, 1)[0];
                    if (db && userId !== 'anonymous') {
                        await deleteCalculatedPlan(userId, rowId);
                    }
                }
            } else if (fromSection === 'running') {
                const index = runningPlansData.findIndex(plan => plan.rowId === rowId);
                if (index !== -1) {
                    planToExecute = runningPlansData.splice(index, 1)[0];
                    if (db && userId !== 'anonymous') {
                        await deleteRunningPlan(userId, rowId);
                    }
                }
            }

            if (planToExecute) {
                planToExecute.outcome = outcome;
                planToExecute.timestamp = new Date().toISOString();
                
                if (outcome === 'Tes') {
                    planToExecute.note = 'Tes selesai silahkan chek di bagian Ringkasan Bulanan (Akumulasi).';
                }

                executedPlansData.push(planToExecute);
                
                if (db && userId !== 'anonymous') {
                    await saveExecutedPlan(userId, planToExecute);
                } else {
                    saveDataToLocalStorage(); // Fallback to local storage
                }

                renderCalculatedPlans();
                renderRunningPlans();
                renderExecutedPlans();
                
                // --- GANTI DENGAN BLOK INI ---
                calculateSummaryStatistics();
                updateRiskRewardStatistics();
                // --- PERBAIKAN: Panggil semua fungsi ringkasan secara konsisten ---
                calculateAndRenderDailySummary();
                calculateAndRenderWeeklySummary();
                calculateAndRenderNewMonthlySummary();
                calculateAndRenderYearlySummary();
                // --- AKHIR PERBAIKAN ---
                handleSimulatorInputChange();

                for (const sectionId in chartSections) {
                    const chartInfo = chartSections[sectionId];
                    if (chartInfo.chartInstance && chartInfo.chartInstance()) { chartInfo.chartInstance().destroy(); chartInfo.setInstance(null); chartInfo.hasRendered = false; }
                }
                console.log("Trade completed and data updated.");
            } else { console.warn(`Trade dengan rowId ${rowId} tidak ditemukan di rencana ${fromSection}.`); }
        }
        /**
         * PERBAIKAN: Memperbaiki kesalahan referensi fungsi dan alur validasi.
         * @param {string} rowId The ID of the plan to move.
         */
        async function setRunning(rowId) {
            console.log(`Setting trade for rowId: ${rowId} to Running`);
            const index = calculatedPlansData.findIndex(plan => plan.rowId === rowId);
            if (index === -1) {
                console.warn(`Trade dengan rowId ${rowId} tidak ditemukan di rencana yang dihitung.`);
                return;
            }
            const planToRun = calculatedPlansData[index];

            // --- ATURAN BARU: Validasi Batas Risiko Aktif ---
            const currentActiveRisk = runningPlansData.reduce((total, plan) => total + (plan.rrPercentage?.sl || 0), 0);
            const newPlanRisk = planToRun.rrPercentage?.sl || 0;
            if ((currentActiveRisk + newPlanRisk) > MAX_ACTIVE_RISK_PERCENT) {
                showMessageBox(
                    'Batas Risiko Aktif Tercapai',
                    `Total risiko aktif Anda akan melebihi batas maksimal (${MAX_ACTIVE_RISK_PERCENT.toFixed(2)}%). Selesaikan salah satu trade yang sedang berjalan untuk membuka posisi baru.`,
                    false
                );
                return; // Hentikan eksekusi jika batas terlampaui
            }

            // --- PERBAIKAN: Validasi Aturan Pending Pips disederhanakan ---
            const pendingPipsRule = PENDING_PIPS_RULES[planToRun.symbol];
            if (pendingPipsRule !== undefined) {
                const assetData = getAssetData(planToRun.symbol);
                const assetType = assetData.type;

                // Logika ini sekarang berlaku untuk Forex dan Komoditas
                if (assetType === 'forexMajor' || assetType === 'forexCross' || assetType === 'commodity') {
                    const visualPointsData = getVisualPoints(planToRun.pendingPips, planToRun.symbol);
                    // 'actualVisualValue' sekarang selalu merupakan nilai pips visual
                    const actualVisualValue = visualPointsData.forCalc; 
                    // 'minRequiredValue' adalah aturan pips langsung dari konstanta
                    const minRequiredValue = pendingPipsRule;

                    if (actualVisualValue < minRequiredValue) {
                        const neededValue = minRequiredValue - actualVisualValue;
                        const notificationMessage = `Pending pips untuk ${planToRun.symbol} minimal ${minRequiredValue} pips. Anda memerlukan ${neededValue} pips lagi.`;
                        showMessageBox('Aturan Pending Pips', notificationMessage, false);
                        return; // Hentikan eksekusi
                    }
                }
            }

            if (!checkTradeLimits()) {
                showMessageBox('Batas Risiko Tercapai', limitNotificationMessage, false);
                return;
            }
            // --- Akhir dari Validasi Aturan ---

            // Jika semua validasi lolos, pindahkan rencana
            calculatedPlansData.splice(index, 1);
            runningPlansData.push(planToRun);

            // Simpan perubahan ke database/local storage
            if (db && userId !== 'anonymous') {
                await deleteCalculatedPlan(userId, rowId);
                await saveRunningPlan(userId, planToRun);
            } else {
                saveDataToLocalStorage();
            }

            // Render ulang tabel untuk memperbarui UI
            renderCalculatedPlans();
            renderRunningPlans();
            console.log("Trade moved to Running plans.");
        }

        async function editRunningPlan(rowId) {
            console.log(`Mengedit trade yang berjalan untuk rowId: ${rowId}`);
            const index = runningPlansData.findIndex(plan => plan.rowId === rowId);
            if (index !== -1) {
                const planToEdit = runningPlansData.splice(index, 1)[0]; // Hapus dari rencana yang berjalan
                if (db && userId !== 'anonymous') {
                    await deleteRunningPlan(userId, rowId);
                } else {
                    saveDataToLocalStorage();
                }

                // Tambahkan baris input baru dan isi dengan data dari rencana yang akan diedit
                addInputRow(planToEdit); // Lewati data rencana untuk mengisi formulir sebelumnya

                renderRunningPlans(); // Render ulang rencana yang berjalan untuk mencerminkan penghapusan
                console.log("Trade dipindahkan dari rencana Berjalan ke formulir input untuk diedit.");
            }
        }

        // --- DYNAMIC INPUT ROW MANAGEMENT ---
        function addInputRow(initialData = {}) {
            rowCounter++; const newRowId = `inputRow-${rowCounter}`;
            const groupedAssets = { 'Forex Mayor': [], 'Forex Cross Rate': [], 'Forex Eksotis': [], 'Komoditas': [], 'Indeks': [], 'Kripto': [] };
            Object.keys(assetValues).forEach(symbol => {
                const asset = assetValues[symbol]; let categoryLabel;
                switch (asset.type) {
                    case 'forexMajor': categoryLabel = 'Forex Mayor'; break; case 'forexCross': categoryLabel = 'Forex Cross Rate'; break;
                    case 'forexExotic': categoryLabel = 'Forex Eksotis'; break; case 'commodity': categoryLabel = 'Komoditas'; break;
                    case 'index': categoryLabel = 'Indeks'; break; case 'crypto': categoryLabel = 'Kripto'; break; default: categoryLabel = 'Lainnya';
                }
                if (!groupedAssets[categoryLabel]) groupedAssets[categoryLabel] = [];
                groupedAssets[categoryLabel].push(symbol);
            });
            let symbolsOptions = '<option value="" disabled selected>Pilih Aset</option>'; // Added default option
            const categoryOrder = ['Forex Mayor', 'Forex Cross Rate', 'Forex Eksotis', 'Komoditas', 'Indeks', 'Kripto', 'Lainnya'];
            categoryOrder.forEach(category => {
                if (groupedAssets[category] && groupedAssets[category].length > 0) {
                    symbolsOptions += `<optgroup label="${category}">`;
                    groupedAssets[category].sort().forEach(symbol => { symbolsOptions += `<option value="${symbol}">${symbol}</option>`; });
                    symbolsOptions += `</optgroup>`;
                }
            });
const rowHtml = `
                <div id="${newRowId}" class="input-row bg-white p-6 rounded-lg border border-gray-200 relative">
                    <button type="button" class="delete-row-btn absolute top-3 right-3"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg></button>
                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-y-4 gap-x-6">
                        <div><label for="symbol-${rowCounter}" class="block text-sm input-label mb-1">Aset</label><select id="symbol-${rowCounter}" name="symbol" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-gray-300 focus:border-gray-300 sm:text-sm select-field">${symbolsOptions}</select></div>
                        <div><label for="tradeType-${rowCounter}" class="block text-sm input-label mb-1">Tipe Trade</label><div class="flex rounded-md shadow-sm"><button type="button" id="buyBtn-${rowCounter}" class="buy-button w-1/2 py-2 px-4 rounded-l-md border text-center font-medium">BUY</button><button type="button" id="sellBtn-${rowCounter}" class="sell-button w-1/2 py-2 px-4 rounded-r-md border text-center font-medium">SELL</button></div></div>
                        <div><label for="balance-${rowCounter}" class="block text-sm input-label mb-1">Balance Akun ($)</label><input type="number" id="balance-${rowCounter}" name="balance" step="0.01" value="${initialData.balance !== undefined ? initialData.balance : ''}" placeholder="Cth: 10000" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                        <div class="input-group-percent"><label for="riskPercent-${rowCounter}" class="block text-sm input-label mb-1">Risiko (%)</label><div class="flex mt-1"><input type="number" id="riskPercent-${rowCounter}" name="riskPercent" step="0.01" value="${initialData.riskPercent !== undefined ? initialData.riskPercent : ''}" placeholder="Cth: 0.2" class="block w-full border rounded-l-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"><span class="inline-flex items-center px-3 border border-l-0 rounded-r-md text-sm font-medium"> % </span></div><p id="riskLimitNote-${rowCounter}" class="text-red-500 text-xs mt-1 hidden">Risiko maksimal adalah ${MAX_RISK_PER_TRADE}%</p></div>
                        <div><label for="priceNow-${rowCounter}" class="block text-sm input-label mb-1">Price Now</label><input type="number" id="priceNow-${rowCounter}" name="priceNow" step="any" value="${initialData.priceNow !== undefined ? initialData.priceNow : ''}" placeholder="Cth: 1.07500 / 35000.50" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                        <div><label for="openPrice-${rowCounter}" class="block text-sm input-label mb-1">Open Price</label><input type="number" id="openPrice-${rowCounter}" name="openPrice" step="any" value="${initialData.openPrice !== undefined ? initialData.openPrice : ''}" placeholder="Cth: 1.07500 / 35000.50" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field">
                        </div>
                        <div><label for="slPrice-${rowCounter}" class="block text-sm input-label mb-1">SL Price</label><input type="number" id="slPrice-${rowCounter}" name="slPrice" step="any" value="${initialData.slPrice !== undefined ? initialData.slPrice : ''}" placeholder="Cth: 1.07000 / 34900.00" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                        <div><label for="tpPrice-${rowCounter}" class="block text-sm input-label mb-1">TP Price</label><input type="number" id="tpPrice-${rowCounter}" name="tpPrice" step="any" value="${initialData.tpPrice !== undefined ? initialData.tpPrice : ''}" placeholder="Cth: 1.09000 / 35500.00" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                        <div><label for="note-${rowCounter}" class="block text-sm input-label mb-1">Catatan (Opsional)</label><input type="text" id="note-${rowCounter}" name="note" value="${initialData.note !== undefined ? initialData.note : ''}" placeholder="Cth: Breakout strategy" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                    </div>
                </div>
            `;
            inputRowsContainer.insertAdjacentHTML('beforeend', rowHtml);
            
            // Attach event listeners to all inputs in the new row to save data automatically
            const newRowElement = document.getElementById(newRowId);
            newRowElement.querySelectorAll('input, select').forEach(input => {
                input.addEventListener('change', saveInputRowsToLocalStorage);
            });
            const buyBtn = newRowElement.querySelector(`#buyBtn-${rowCounter}`);
            const sellBtn = newRowElement.querySelector(`#sellBtn-${rowCounter}`);
            
            buyBtn.addEventListener('click', () => {
                buyBtn.classList.add('active');
                sellBtn.classList.remove('active');
                saveInputRowsToLocalStorage();
            });
            sellBtn.addEventListener('click', () => {
                sellBtn.classList.add('active');
                buyBtn.classList.remove('active');
                saveInputRowsToLocalStorage();
            });

            newRowElement.querySelector('.delete-row-btn').addEventListener('click', () => {
                newRowElement.remove();
                saveInputRowsToLocalStorage();
            });


            const symbolSelect = document.getElementById(`symbol-${rowCounter}`);
            const priceNowInput = document.getElementById(`priceNow-${rowCounter}`);
            const openPriceInput = document.getElementById(`openPrice-${rowCounter}`);
            const slPriceInput = document.getElementById(`slPrice-${rowCounter}`);
            const tpPriceInput = document.getElementById(`tpPrice-${rowCounter}`);

            const updatePriceInputStepsAndFormat = (selectedSymbol) => {
                const assetData = getAssetData(selectedSymbol);
                const decimals = assetData ? assetData.decimals : 5;
                const stepValue = getStepValue(decimals);

                [priceNowInput, openPriceInput, slPriceInput, tpPriceInput].forEach(input => {
                    if (input) { // Add null check here
                        input.setAttribute('step', stepValue);
                        if (input.value !== '') {
                            // Only format the value if it's not empty, to avoid changing user's partial input
                            input.value = parseFloat(input.value).toFixed(decimals);
                        }
                    }
                });
            };

            if (symbolSelect) { // Add null check here
                symbolSelect.addEventListener('change', (event) => {
                    updatePriceInputStepsAndFormat(event.target.value);
                });
            }

            // Apply formatting on blur for price inputs
            [priceNowInput, openPriceInput, slPriceInput, tpPriceInput].forEach(input => {
                if (input) { // Add null check here
                    input.addEventListener('blur', (event) => {
                        if (symbolSelect && event.target.value !== '') { // Add null check and empty string check
                            const assetData = getAssetData(symbolSelect.value);
                            const decimals = assetData ? assetData.decimals : 5;
                            event.target.value = parseFloat(event.target.value).toFixed(decimals);
                        }
                    });
                }
            });

            if (initialData.tradeType === 'BUY') { if (buyBtn) buyBtn.classList.add('active'); if (sellBtn) sellBtn.classList.remove('active'); }
            else if (initialData.tradeType === 'SELL') { if (sellBtn) sellBtn.classList.add('active'); if (buyBtn) buyBtn.classList.remove('active'); }
            else { if (buyBtn) buyBtn.classList.add('active'); if (sellBtn) sellBtn.classList.remove('active'); }
            
            if (initialData.symbol && symbolSelect) { // Add null check here
                symbolSelect.value = initialData.symbol;
                // Pastikan pemformatan awal dan pengaturan langkah untuk data yang dimuat
                updatePriceInputStepsAndFormat(initialData.symbol);
            }

            const riskPercentInput = document.getElementById(`riskPercent-${rowCounter}`); const riskLimitNote = document.getElementById(`riskLimitNote-${rowCounter}`);
            if (riskPercentInput) { // Add null check here
                riskPercentInput.addEventListener('input', () => {
                    let value = parseFloat(riskPercentInput.value);
                    if (isNaN(value)) { if (riskLimitNote) riskLimitNote.classList.add('hidden'); return; }
                    if (value > MAX_RISK_PER_TRADE) { riskPercentInput.value = MAX_RISK_PER_TRADE; if (riskLimitNote) riskLimitNote.classList.remove('hidden'); } else { if (riskLimitNote) riskLimitNote.classList.add('hidden'); }
                });
            }
            if (newRowElement) { // Add null check here
                newRowElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
            console.log("Baris input ditambahkan:", newRowId);
        }

        /**
/**
 * Mengonversi array data menjadi string CSV dan memicu unduhan.
 * @param {string} filename - Nama file yang akan diunduh.
 * @param {Array<Object>} dataArray - Array berisi objek data.
 * @param {Array<string>} headers - Array berisi header untuk kolom CSV.
 */
function downloadAsExcel(filename, dataArray, headers) {
    if (!dataArray || dataArray.length === 0) {
        showMessageBox('Informasi', 'Tidak ada data untuk diunduh.', false);
        return;
    }

    let csvContent = headers.join(',') + '\r\n';

    dataArray.forEach(row => {
        const rowData = headers.map(header => {
            // PERBAIKAN 1: Mengambil nilai langsung menggunakan header sebagai kunci.
            // Ini memperbaiki masalah di mana kolom "R:R %" tidak ditemukan.
            let value = row[header];
            let valueStr = (value !== undefined && value !== null) ? String(value) : '';

            // PERBAIKAN 2: Logika quoting yang lebih baik untuk format CSV yang benar.
            // Jika nilai sudah diapit tanda kutip oleh fungsi lain (seperti R:R %),
            // kita hapus dulu agar tidak terjadi penggandaan.
            if (valueStr.startsWith('"') && valueStr.endsWith('"')) {
                valueStr = valueStr.substring(1, valueStr.length - 1);
            }

            // Sekarang, terapkan aturan CSV standar: jika mengandung koma atau tanda kutip,
            // apit dengan tanda kutip dan escape tanda kutip yang ada di dalamnya.
            if (valueStr.includes(',') || valueStr.includes('"')) {
                valueStr = `"${valueStr.replace(/"/g, '""')}"`;
            }
            return valueStr;
        });
        csvContent += rowData.join(',') + '\r\n';
    });

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}


    /**
 * Menyiapkan objek plan tunggal menjadi format yang siap diekspor ke CSV.
 * @param {Object} plan - Objek data rencana trading.
 * @param {string} status - Status rencana ('Baru', 'Aktif', 'Selesai').
 * @returns {Object} Objek yang sudah diformat untuk ekspor.
 */
function preparePlanForExport(plan, status) {
    const currentAssetData = plan.assetData || getAssetData(plan.symbol);
    const rrPercentageString = plan.rrPercentage
        ? `"${-formatNumber(plan.rrPercentage.sl, 2)}% : ${formatNumber(plan.rrPercentage.tp, 2)}%"`
        : 'N/A';

    // PERBAIKAN DIMULAI DI SINI:
    // Menentukan apakah rencana ini berasal dari tabel "Selesai"
    const isForExecutedTable = (status === 'Selesai');

    return {
        "Status": status,
        "Aset": plan.symbol || 'N/A',
        "Trade": plan.tradeType,
        "BalanceAkun": plan.balance,
        "WaktuMasuk": plan.entryTime ? new Date(plan.entryTime).toISOString() : 'N/A',
        "OpenPrice": formatNumber(plan.openPrice, currentAssetData.decimals, false),
        "SLPrice": formatNumber(plan.slPrice, currentAssetData.decimals, false),
        "TPPrice": formatNumber(plan.tpPrice, currentAssetData.decimals, false),
        // Menggunakan flag 'isForExecutedTable' untuk mendapatkan nilai visual yang benar
        "PendingPipsPoints": getVisualPoints(plan.pendingPips, plan.symbol, isForExecutedTable).display,
        "SLPipsPoints": getVisualPoints(plan.slPips, plan.symbol, isForExecutedTable).display,
        "TPPipsPoints": getVisualPoints(plan.tpPips, plan.symbol, isForExecutedTable).display,
        "RRPips": plan.rrPips > 0 ? `1:${formatNumber(plan.rrPips, 1, false)}` : 'N/A',
        "R:R %": rrPercentageString,
        "LotUnits": formatNumber(plan.lotSize, 2),
        "NettSL": plan.nettSL,
        "NettTP": plan.nettTP,
        "Catatan": plan.note || '-',
        "Hasil": plan.outcome || 'N/A',
        "WaktuKeluar": plan.timestamp ? new Date(plan.timestamp).toISOString() : 'N/A'
    };
    // PERBAIKAN SELESAI DI SINI
}



        if (downloadExecutedExcelBtn) {
            downloadExecutedExcelBtn.addEventListener('click', () => {
                // PERBAIKAN: Ganti header "RRSL" dan "RRTP" dengan "R:R %"
                const headers = ["Status", "Aset", "Trade", "BalanceAkun", "WaktuMasuk", "OpenPrice", "SLPrice", "TPPrice", "PendingPipsPoints", "SLPipsPoints", "TPPipsPoints", "RRPips", "R:R %", "LotUnits", "NettSL", "NettTP", "Catatan", "Hasil", "WaktuKeluar"];
                
                const dataToExport = executedPlansData.map(plan => preparePlanForExport(plan, 'Selesai'));
                downloadAsExcel(`Rencana_Trading_Selesai_${new Date().toISOString().slice(0, 10)}.csv`, dataToExport, headers);
            });
        }
        
        // --- GANTI SELURUH BLOK EVENT LISTENER LAMA DENGAN FUNGSI BARU DI BAWAH INI ---

        if (downloadAllExcelBtn) {
            downloadAllExcelBtn.addEventListener('click', () => {
                try {
                    console.log("Preparing comprehensive Excel file for download...");
                    if (executedPlansData.length === 0) {
                        showMessageBox('Informasi', 'Tidak ada data trading yang selesai untuk diunduh.', false);
                        return;
                    }

                    // 1. Buat Workbook Excel Baru
                    const wb = XLSX.utils.book_new();

                    // 2. Sheet 1 & 2: Statistik Ringkasan dan Risiko (sesuai urutan)
                    const summaryStats = calculateSummaryStatistics();
                    const riskStats = updateRiskRewardStatistics();

                    const summaryData = [
                        ["Statistik Ringkasan Keseluruhan"], [],
                        ["Total Trade Selesai", summaryStats.totalSettledTrades],
                        ["Probabilitas", `${summaryStats.probability}%`],
                        ["Total Pips/Points", summaryStats.totalPips],
                        ["Saldo Akun Akhir", summaryStats.finalBalance],
                        ["Persentase Keseluruhan", `${summaryStats.overallPercentage}%`],
                        ["Waktu Bergabung", summaryStats.joinTime],
                        ["Maksimum Drawdown Saldo", summaryStats.balanceDrawdown],
                        ["Periode Drawdown Saldo", summaryStats.balanceDrawdownPeriod],
                        ["Maksimum Drawdown %", `${summaryStats.overallMaxDrawdownPercentage}%`],
                        ["Periode Drawdown %", summaryStats.overallMaxDrawdownPercentagePeriod]
                    ];
                    const ws_summary = XLSX.utils.aoa_to_sheet(summaryData);
                    ws_summary['!cols'] = [{ wch: 35 }, { wch: 25 }];
                    XLSX.utils.book_append_sheet(wb, ws_summary, "1. Ringkasan Keseluruhan");

                    const riskData = [
                        ["Statistik Risiko dan Imbalan"], [],
                        ["Rata-rata R:R", `1 : ${formatNumber(riskStats.avgRiskRewardVal, 1)}`],
                        ["Rata-rata Sinyal/Bulan", riskStats.avgSignalSettledMonthVal],
                        ["Rata-rata Periode Penahanan", formatDuration(riskStats.avgHoldingPeriodMsVal)],
                        ["Rata-rata TP Pips", riskStats.avgTpPipsVal],
                        ["Rata-rata SL Pips", riskStats.avgSlPipsVal],
                        ["Keuntungan Beruntun", riskStats.maxProfitStreak],
                        ["Kerugian Beruntun", riskStats.maxLossStreak],
                        ["Rata-rata Pips", riskStats.avgPipsVal],
                        ["Laba Kotor", riskStats.grossProfit],
                        ["Rugi Kotor", riskStats.grossLoss]
                    ];
                    const ws_risk = XLSX.utils.aoa_to_sheet(riskData);
                    ws_risk['!cols'] = [{ wch: 35 }, { wch: 25 }];
                    XLSX.utils.book_append_sheet(wb, ws_risk, "2. Risiko & Imbalan");

                    // 3. Sheet 3-6: Ringkasan Harian, Mingguan, Bulanan, Tahunan
                    const dailyAoA = tableToAoA(document.getElementById('newDailySummaryBody'), ["Tanggal", "Presentase Kumulatif", "Total Pips Kumulatif", "Total Trade", "Saldo Akhir Kumulatif"]);
                    const weeklyAoA = tableToAoA(document.getElementById('newWeeklySummaryBody'), ["Minggu", "Presentase Kumulatif", "Total Pips Kumulatif", "Total Trade", "Saldo Akhir Kumulatif"]);
                    const monthlyAoA = tableToAoA(document.getElementById('newMonthlySummaryBody'), ["Bulan", "Presentase Kumulatif", "Total Pips Kumulatif", "Total Trade", "Saldo Akhir Kumulatif"]);
                    const yearlyAoA = tableToAoA(document.getElementById('newYearlySummaryBody'), ["Tahun", "Presentase Kumulatif", "Total Pips Kumulatif", "Total Trade", "Saldo Akhir Kumulatif"]);

                    const ws_daily = XLSX.utils.aoa_to_sheet(dailyAoA);
                    const ws_weekly = XLSX.utils.aoa_to_sheet(weeklyAoA);
                    const ws_monthly = XLSX.utils.aoa_to_sheet(monthlyAoA);
                    const ws_yearly = XLSX.utils.aoa_to_sheet(yearlyAoA);

                    const summaryCols = [{wch: 25},{wch: 20},{wch: 20},{wch: 15},{wch: 20}];
                    ws_daily['!cols'] = summaryCols;
                    ws_weekly['!cols'] = summaryCols;
                    ws_monthly['!cols'] = summaryCols;
                    ws_yearly['!cols'] = summaryCols;

                    XLSX.utils.book_append_sheet(wb, ws_daily, "3. Ringkasan Harian");
                    XLSX.utils.book_append_sheet(wb, ws_weekly, "4. Ringkasan Mingguan");
                    XLSX.utils.book_append_sheet(wb, ws_monthly, "5. Ringkasan Bulanan");
                    XLSX.utils.book_append_sheet(wb, ws_yearly, "6. Ringkasan Tahunan");

                    // 4. Sheet 7: Data Rencana Trading Selesai
                    const headers = ["Status", "Aset", "Trade", "BalanceAkun", "WaktuMasuk", "OpenPrice", "SLPrice", "TPPrice", "PendingPipsPoints", "SLPipsPoints", "TPPipsPoints", "RRPips", "R:R %", "LotUnits", "NettSL", "NettTP", "Catatan", "Hasil", "WaktuKeluar"];
                    const executedExportData = executedPlansData.map(p => preparePlanForExport(p, 'Selesai'));
                    const ws_executed = XLSX.utils.json_to_sheet(executedExportData, { header: headers });
                    const tradeDataColWidths = [{wch:10},{wch:15},{wch:8},{wch:15},{wch:20},{wch:15},{wch:15},{wch:15},{wch:18},{wch:15},{wch:15},{wch:12},{wch:18},{wch:12},{wch:15},{wch:15},{wch:25},{wch:15},{wch:20}];
                    ws_executed['!cols'] = tradeDataColWidths;
                    XLSX.utils.book_append_sheet(wb, ws_executed, "7. Rencana Trading Selesai");

                    // 5. Unduh File Excel
                    XLSX.writeFile(wb, `Laporan_Trading_Lengkap_${new Date().toISOString().slice(0, 10)}.xlsx`);
                    showMessageBox('Berhasil', 'File Excel yang komprehensif telah berhasil diunduh.', false);
                
                } catch (error) {
                    console.error("Gagal membuat file Excel:", error);
                    showMessageBox('Gagal Mengunduh', 'Terjadi kesalahan saat menyiapkan data untuk diunduh. Silakan periksa konsol untuk detail teknis (Tekan F12 -> Console).', false);
                }
            });
        }
        
        async function exportToPdf(elementId, filename) {
            const element = document.getElementById(elementId);
            if (!element) { console.log('Elemen tidak ditemukan untuk diunduh PDF.'); return; }
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.7);color:white;padding:20px;border-radius:10px;z-index:1000;';
            loadingDiv.textContent = 'Membuat PDF...'; document.body.appendChild(loadingDiv);
            try {
                const canvas = await html2canvas(element, { scale: 2 });
                const imgData = canvas.toDataURL('image/png'); const { jsPDF } = window.jspdf; const pdf = new jsPDF('p', 'mm', 'a4');
                const imgWidth = 210; const pageHeight = 297; const imgHeight = canvas.height * imgWidth / canvas.width;
                let heightLeft = imgHeight; let position = 0;
                pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight); heightLeft -= pageHeight;
                while (heightLeft >= 0) { position = heightLeft - imgHeight; pdf.addPage(); pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight); heightLeft -= pageHeight; }
                pdf.save(filename);
            } catch (error) { console.error("Error generating PDF:", error); console.log('Gagal membuat PDF: ' + error.message); }
            finally { document.body.removeChild(loadingDiv); }
        }

        /**
         * FUNGSI BANTUAN BARU: Memaksa semua bagian (terutama grafik) untuk dirender
         * sebelum diekspor ke PDF, mengatasi masalah lazy loading dan animasi.
         */
        async function renderAllSectionsForExport() {
            console.log("Force-rendering all sections for PDF export...");
            const renderPromises = [];
            // Loop melalui semua bagian yang terdaftar di chartSections
            for (const sectionId in chartSections) {
                const chartInfo = chartSections[sectionId];
                // Jika bagian tersebut memiliki fungsi render, jalankan
                if (chartInfo && typeof chartInfo.render === 'function') {
                    renderPromises.push(chartInfo.render());
                }
            }
            // Tunggu semua proses render selesai
            await Promise.all(renderPromises);
            console.log("All sections rendered for export.");
        }
        /**
         * FUNGSI YANG DIPERBARUI: Membuat laporan PDF komprehensif.
         * PERBAIKAN: Menonaktifkan IntersectionObserver untuk animasi scroll selama proses
         * pembuatan PDF untuk memastikan semua elemen terlihat dan berhasil ditangkap.
         * @param {string} filename - Nama file untuk PDF yang akan diunduh.
         */
        async function downloadAllDataAsPdf(filename) {
            // 0. Simpan posisi scroll awal pengguna
            const initialScrollY = window.scrollY;

            // Tampilkan pesan loading
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.85); color:white; padding:25px; border-radius:10px; z-index:1001; font-family: "Inter", sans-serif; text-align: center;';
            const progressText = document.createElement('div');
            loadingDiv.appendChild(progressText);
            document.body.appendChild(loadingDiv);

            // --- INTI PERBAIKAN: Matikan animasi ---
            if (scrollObserver) {
                scrollObserver.disconnect();
            }
            // Paksa semua bagian untuk terlihat (menghapus efek opacity: 0 dari animasi)
            document.querySelectorAll('.scroll-animate-section').forEach(section => {
                section.classList.add('scrolled-into-view');
            });
            // --- AKHIR PERBAIKAN ---

            Chart.defaults.animation = false;
            progressText.textContent = 'Merender semua grafik...';
            await renderAllSectionsForExport();

            const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                const pageHeight = pdf.internal.pageSize.getHeight();
                const topMargin = 15;
                const bottomMargin = 15;
                let finalY = topMargin;

                // Helper functions (tidak ada perubahan di sini)
                const checkPageOverflow = (contentHeight) => { if (finalY + contentHeight > pageHeight - bottomMargin) { pdf.addPage(); finalY = topMargin; } };
                const addSectionTitle = (title) => { checkPageOverflow(12); pdf.setFontSize(14); pdf.setFont('helvetica', 'bold'); pdf.text(title, 15, finalY); finalY += 8; };
                const captureVisibleElement = async (elementId) => {
                    progressText.textContent = `Memproses: ${elementId}...`;
                    const element = document.getElementById(elementId);
                    if (!element) { console.warn(`Elemen '${elementId}' tidak ditemukan.`); return; }
                    element.scrollIntoView({ behavior: 'auto', block: 'center' });
                    await delay(500);
                    const canvas = await html2canvas(element, { scale: 2.5, backgroundColor: '#ffffff', useCORS: true });
                    const imgWidth = 180; const imgHeight = canvas.height * imgWidth / canvas.width;
                    checkPageOverflow(imgHeight);
                    pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 15, finalY, imgWidth, imgHeight);
                    finalY += imgHeight + 8;
                };

                // --- 1. JUDUL DAN SEMUA BAGIAN TABEL ---
                progressText.textContent = 'Membangun tabel...';
                // (Kode untuk membuat judul dan semua tabel dengan autoTable tetap sama)
                pdf.setFontSize(20); pdf.setFont('helvetica', 'light'); pdf.text('Laporan Analisis Kinerja Trading Lengkap', 105, finalY, { align: 'center' }); finalY += 8;
                pdf.setFontSize(10); pdf.setTextColor(100); pdf.text(`Dihasilkan pada: ${new Date().toLocaleDateString('id-ID', { dateStyle: 'full' })}`, 105, finalY, { align: 'center' }); finalY += 15;
                const planHeadersFull = ["Aset", "Trade", "Balance Akun", "Waktu Masuk", "Open Price", "SL Price", "TP Price", "Pending Pips/Points", "SL Pips/Points", "TP Pips/Points", "R:R Pips", "R:R %", "Lot/Units", "Nett SL", "Nett TP", "Catatan", "Hasil/Aksi"];
                const executedPlanHeadersFull = [...planHeadersFull.slice(0, 16), "Hasil", "Waktu Keluar"];
                const mapPlanToFullArray = (p, status) => { const currentAssetData = p.assetData || getAssetData(p.symbol); const rrPercentageString = p.rrPercentage ? `${-formatNumber(p.rrPercentage.sl, 2)}% : ${formatNumber(p.rrPercentage.tp, 2)}%` : 'N/A'; return [ p.symbol, p.tradeType, formatCurrency(p.balance), new Date(p.entryTime).toLocaleTimeString('id-ID'), formatNumber(p.openPrice, currentAssetData.decimals, false), formatNumber(p.slPrice, currentAssetData.decimals, false), formatNumber(p.tpPrice, currentAssetData.decimals, false), getVisualPoints(p.pendingPips, p.symbol, status === 'Selesai').display, getVisualPoints(p.slPips, p.symbol, status === 'Selesai').display, getVisualPoints(p.tpPips, p.symbol, status === 'Selesai').display, p.rrPips > 0 ? `1:${formatNumber(p.rrPips, 1)}` : 'N/A', rrPercentageString, formatNumber(p.lotSize, 2), formatCurrency(p.nettSL), formatCurrency(p.nettTP), p.note || '-', status === 'Selesai' ? p.outcome : status, ...(status === 'Selesai' ? [new Date(p.timestamp).toLocaleTimeString('id-ID')] : []) ]; };
                addSectionTitle('Rencana Trading Baru'); pdf.autoTable({ startY: finalY, head: [planHeadersFull], body: calculatedPlansData.map(p => mapPlanToFullArray(p, 'Baru').slice(0, 17)), theme: 'grid', headStyles: { fillColor: [22, 160, 133] }, styles: { fontSize: 5, cellPadding: 1 } }); finalY = pdf.lastAutoTable.finalY + 8;
                addSectionTitle('Rencana Trading Aktif'); pdf.autoTable({ startY: finalY, head: [planHeadersFull], body: runningPlansData.map(p => mapPlanToFullArray(p, 'Aktif').slice(0, 17)), theme: 'grid', headStyles: { fillColor: [243, 156, 18] }, styles: { fontSize: 5, cellPadding: 1 } }); finalY = pdf.lastAutoTable.finalY + 8;
                addSectionTitle('Rencana Trading Selesai'); pdf.autoTable({ startY: finalY, head: [executedPlanHeadersFull], body: executedPlansData.map(p => mapPlanToFullArray(p, 'Selesai')), theme: 'grid', headStyles: { fillColor: [41, 128, 185] }, styles: { fontSize: 5, cellPadding: 1 } }); finalY = pdf.lastAutoTable.finalY + 8;
                addSectionTitle('Statistik Ringkasan Keseluruhan'); const summaryStats = calculateSummaryStatistics(); pdf.autoTable({ startY: finalY, head: [['Metrik', 'Nilai']], body: summaryStats ? Object.entries(summaryStats).map(([key, val]) => [key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()), val]) : [['Tidak ada data', '']], theme: 'grid' }); finalY = pdf.lastAutoTable.finalY + 8;
                addSectionTitle('Statistik Risiko dan Imbalan'); const riskStats = updateRiskRewardStatistics(); pdf.autoTable({ startY: finalY, head: [['Metrik', 'Nilai']], body: riskStats ? Object.entries(riskStats).map(([key, val]) => [key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()), typeof val === 'number' ? formatNumber(val, 2) : val]) : [['Tidak ada data', '']], theme: 'grid' }); finalY = pdf.lastAutoTable.finalY + 8;
                addSectionTitle('Statistik per Pair'); const assetSuccessData = {}; executedPlansData.forEach(trade => { if (!assetSuccessData[trade.symbol]) assetSuccessData[trade.symbol] = { wins: 0, total: 0 }; if (trade.outcome === 'Take Profit' || trade.outcome === 'Stop Loss') { assetSuccessData[trade.symbol].total++; if (trade.outcome === 'Take Profit') assetSuccessData[trade.symbol].wins++; } }); pdf.autoTable({ startY: finalY, head: [['Pair', 'Probabilitas Menang (%)', 'Rasio Menang/Total']], body: Object.keys(assetSuccessData).map(symbol => { const stats = assetSuccessData[symbol]; const winRate = stats.total > 0 ? (stats.wins / stats.total) * 100 : 0; return [symbol, `${formatNumber(winRate, 2)}%`, `${stats.wins}/${stats.total}`]; }), theme: 'striped' }); finalY = pdf.lastAutoTable.finalY + 8;
                const summaryHeaders = ["Periode", "Presentase Kumulatif", "Pips Kumulatif", "Total Trade", "Saldo Akhir"];
                addSectionTitle('Ringkasan Harian Kumulatif'); pdf.autoTable({ startY: finalY, head: [summaryHeaders], body: tableToAoA(document.getElementById('newDailySummaryBody'), summaryHeaders).slice(1), theme: 'striped' }); finalY = pdf.lastAutoTable.finalY + 8;
                addSectionTitle('Ringkasan Mingguan Kumulatif'); pdf.autoTable({ startY: finalY, head: [summaryHeaders], body: tableToAoA(document.getElementById('newWeeklySummaryBody'), summaryHeaders).slice(1), theme: 'striped' }); finalY = pdf.lastAutoTable.finalY + 8;
                addSectionTitle('Ringkasan Bulanan Kumulatif'); pdf.autoTable({ startY: finalY, head: [summaryHeaders], body: tableToAoA(document.getElementById('newMonthlySummaryBody'), summaryHeaders).slice(1), theme: 'striped' }); finalY = pdf.lastAutoTable.finalY + 8;
                addSectionTitle('Ringkasan Tahunan Kumulatif'); pdf.autoTable({ startY: finalY, head: [summaryHeaders], body: tableToAoA(document.getElementById('newYearlySummaryBody'), summaryHeaders).slice(1), theme: 'striped' }); finalY = pdf.lastAutoTable.finalY + 8;

                // --- 2. SEMUA GRAFIK (DITANGKAP DENGAN SCROLL-TO-CAPTURE) ---
                const chartIdsInOrder = [
                    { id: 'assetSuccessStatisticsSection', title: 'Statistik Keberhasilan Aset' }, { id: 'dailyLineStatisticsSection', title: 'Statistik Persentase Harian' },
                    { id: 'monthlyBarStatisticsSection', title: 'Statistik Persentase Bulanan (Diagram Batang)' }, { id: 'overallPercentageCumulativeStatisticsSection', title: 'Statistik Persentase Kumulatif Keseluruhan (Acuan Balance)' },
                    { id: 'overallBalanceCumulativeStatisticsSection', title: 'Statistik Saldo Akun Kumulatif Keseluruhan' }, { id: 'overallPipsCumulativeStatisticsSection', title: 'Statistik Pips/Points Kumulatif Keseluruhan' },
                    { id: 'combinedSummaryBarStatisticsSection', title: 'Ringkasan Akumulasi Gabungan (Diagram Batang)' }, { id: 'balanceFrequencyStatisticsSection', title: 'Frekuensi Balance per Aset' },
                    { id: 'percentageFrequencyStatisticsSection', title: 'Frekuensi Persentase per Aset' }, { id: 'pipsFrequencyStatisticsSection', title: 'Frekuensi Pips/Points per Aset' },
                    { id: 'executionFrequencyStatisticsSection', title: 'Frekuensi Eksekusi per Aset (BUY vs SELL)' }, { id: 'assetExecutionCountStatisticsSection', title: 'Frekuensi Aset Selesai Dieksekusi' },
                    { id: 'tradeFrequencyStatisticsSection', title: 'Frekuensi Eksekusi Trade per Aset' }
                ];
                
                for (const chart of chartIdsInOrder) {
                    addSectionTitle(chart.title);
                    await captureVisibleElement(chart.id);
                }

                // --- 3. FINALISASI DAN SIMPAN PDF ---
                progressText.textContent = 'Menyelesaikan Laporan...';
                const pageCount = pdf.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    pdf.setPage(i);
                    pdf.setFontSize(8);
                    pdf.setTextColor(150);
                    pdf.text(`Halaman ${i} dari ${pageCount}`, 105, pageHeight - 7, { align: 'center' });
                }

                pdf.save(filename);
                showMessageBox('Berhasil', 'Laporan PDF komprehensif telah berhasil dibuat.', false);

            } catch (error) {
                console.error("Gagal membuat PDF:", error);
                showMessageBox('Gagal', `Terjadi kesalahan saat membuat file PDF: ${error.message}. Silakan coba lagi.`, false);
            } finally {
                // Bersihkan setelah selesai
                Chart.defaults.animation = true;
                document.body.removeChild(loadingDiv);
                window.scrollTo({ top: initialScrollY, behavior: 'auto' });
                
                // --- INTI PERBAIKAN: Nyalakan kembali animasi ---
                animateOnScroll();
            }
        }

        // --- Photo Upload & Crop Functions ---
        /**
         * Draws an image onto a canvas, ensuring it covers the canvas area
         * while maintaining aspect ratio, effectively cropping it to 1:1.
         * @param {CanvasRenderingContext2D} ctx The canvas rendering context.
         * @param {HTMLImageElement} img The image to draw.
         * @param {number} canvasWidth The width of the canvas.
         * @param {number} canvasHeight The height of the canvas.
         */
        function drawImageCover(ctx, img, canvasWidth, canvasHeight) {
            const imgAspectRatio = img.width / img.height;
            const canvasAspectRatio = 1 / 1; // Target aspect ratio

            let sx, sy, sWidth, sHeight;

            // Calculate the source rectangle (the part of the image to crop)
            if (imgAspectRatio > canvasAspectRatio) {
                // Image is wider than 1:1, crop from the sides
                sHeight = img.height;
                sWidth = sHeight * canvasAspectRatio;
                sx = (img.width - sWidth) / 2;
                sy = 0;
            } else {
                // Image is taller than 1:1, crop from top and bottom
                sWidth = img.width;
                sHeight = sWidth / canvasAspectRatio;
                sx = 0;
                sy = (img.height - sHeight) / 2;
            }

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, canvasWidth, canvasHeight);
        }

        function renderPhotoGallery() {
            if (!photoSlides) {
                console.error("photoSlides is null. Cannot render photo gallery.");
                return;
            }
            photoSlides.innerHTML = ''; // Clear existing images

            if (userPhotos.length === 0) {
                photoSlides.innerHTML = '<img src="https://placehold.co/600x600/cccccc/ffffff?text=Add+Photos+1:1" alt="Placeholder" class="w-full h-full object-cover flex-shrink-0">';
                if (prevPhotoBtn) prevPhotoBtn.classList.add('hidden');
                if (nextPhotoBtn) nextPhotoBtn.classList.add('hidden');
                if (photoCounter) photoCounter.classList.add('hidden');
                return;
            }

            userPhotos.forEach((photoUrl, index) => {
                const img = document.createElement('img');
                img.src = photoUrl;
                img.alt = `User Photo ${index + 1}`;
                img.className = 'w-full h-full object-cover flex-shrink-0';
                photoSlides.appendChild(img);
            });

            if (photoSlides) photoSlides.style.transform = `translateX(-${currentPhotoIndex * 100}%)`;
            if (prevPhotoBtn) prevPhotoBtn.classList.toggle('hidden', userPhotos.length <= 1 || currentPhotoIndex === 0);
            if (nextPhotoBtn) nextPhotoBtn.classList.toggle('hidden', userPhotos.length <= 1 || currentPhotoIndex === userPhotos.length - 1);
            if (photoCounter) photoCounter.classList.toggle('hidden', userPhotos.length === 0);
            if (photoCounter) photoCounter.textContent = `${currentPhotoIndex + 1} / ${userPhotos.length}`;
        }

        function showNextPhoto() {
            if (currentPhotoIndex < userPhotos.length - 1) {
                currentPhotoIndex++;
                renderPhotoGallery();
            }
        }

        function showPrevPhoto() {
            if (currentPhotoIndex > 0) {
                currentPhotoIndex--;
                renderPhotoGallery();
            }
        }

        // Long press variables
        let longPressTimer;
        let isLongPress = false;
        const LONG_PRESS_THRESHOLD = 500; // milliseconds
        const MOVE_THRESHOLD = 10; // pixels
        let startX, startY;

        // --- REFACTORED PHOTO EVENT LISTENERS ---
        const photoGalleryContainer = document.querySelector('.photo-gallery-container');
        if (photoGalleryContainer) {
            photoGalleryContainer.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return; // Ignore clicks on nav buttons
                if (e.button !== 0) return; // Only left click
                startX = e.clientX;
                startY = e.clientY;
                isLongPress = false;
                longPressTimer = setTimeout(async () => {
                    isLongPress = true;
                    if (userPhotos.length > 0) {
                        const confirmed = await showMessageBox('Hapus Foto?', 'Apakah Anda yakin ingin menghapus foto ini?', true);
                        if (confirmed) {
                            const indexToDelete = currentPhotoIndex;
                            if (db && userId !== 'anonymous') {
                                await deleteProfilePicture(userId, indexToDelete);
                            } else {
                                userPhotos.splice(indexToDelete, 1);
                                savePhotosToLocalStorage();
                            }
                            if (currentPhotoIndex >= userPhotos.length && userPhotos.length > 0) {
                                currentPhotoIndex = userPhotos.length - 1;
                            } else if (userPhotos.length === 0) {
                                currentPhotoIndex = 0;
                            }
                            renderPhotoGallery();
                            showMessageBox('Berhasil', 'Foto berhasil dihapus.', false);
                        }
                    }
                }, LONG_PRESS_THRESHOLD);
            });

            photoGalleryContainer.addEventListener('mouseup', (e) => {
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
                clearTimeout(longPressTimer);
                if (isLongPress) {
                    e.preventDefault(); // Prevent the label from triggering file input on long press release
                }
                isLongPress = false;
            });

            photoGalleryContainer.addEventListener('touchend', (e) => {
                clearTimeout(longPressTimer);
                if (isLongPress) {
                    e.preventDefault(); // Prevent the label click after a long press
                }
                isLongPress = false;
            });

            photoGalleryContainer.addEventListener('touchmove', (e) => {
                if (longPressTimer && (Math.abs(e.touches[0].clientX - startX) > MOVE_THRESHOLD || Math.abs(e.touches[0].clientY - startY) > MOVE_THRESHOLD)) {
                    clearTimeout(longPressTimer);
                }
            });
        }


        if (imageInput) {
            imageInput.addEventListener('change', (event) => {
                // Check if the upload is allowed
                if (userPhotos.length >= MAX_PHOTOS) {
                    showMessageBox('Batas Unggahan Tercapai', `Anda hanya dapat mengunggah maksimal ${MAX_PHOTOS} foto.`, false);
                    event.target.value = ''; // Reset file input
                    return;
                }

                const files = event.target.files;
                if (files.length === 0) return;

                const file = files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        currentImageToCrop = new Image();
                        currentImageToCrop.onload = () => {
                            if (photoUploadModal) showModal(photoUploadModal);
                            
                            const canvasSize = 500;
                            imageCanvas.width = canvasSize;
                            imageCanvas.height = canvasSize;

                            drawImageCover(ctx, currentImageToCrop, canvasSize, canvasSize);
                        };
                        currentImageToCrop.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                } else {
                    showMessageBox('Gagal', 'Silakan pilih file gambar yang valid.', false);
                }
                event.target.value = ''; // Reset file input to allow re-uploading the same file
            });
        }

        if (cropAndSaveBtn) {
            cropAndSaveBtn.addEventListener('click', async () => {
                if (currentImageToCrop && imageCanvas) {
                    const imageDataUrl = imageCanvas.toDataURL('image/png');
                    const targetIndex = userPhotos.length;
                    if (db && userId !== 'anonymous') {
                        await saveProfilePicture(userId, imageDataUrl, targetIndex);
                    } else {
                        userPhotos.push(imageDataUrl);
                        savePhotosToLocalStorage();
                        showMessageBox('Berhasil', 'Foto profil berhasil disimpan.', false);
                    }
                    currentPhotoIndex = targetIndex;
                    renderPhotoGallery();
                    if (photoUploadModal) hideModal(photoUploadModal);
                    currentImageToCrop = null;
                }
            });
        }

        if (cancelPhotoBtn) cancelPhotoBtn.addEventListener('click', () => {
            if (photoUploadModal) hideModal(photoUploadModal);
            currentImageToCrop = null;
        });

        if (prevPhotoBtn) prevPhotoBtn.addEventListener('click', (e) => {
            e.preventDefault(); // Prevent label click
            e.stopPropagation(); // Stop event from bubbling up
            showPrevPhoto();
        });
        if (nextPhotoBtn) nextPhotoBtn.addEventListener('click', (e) => {
            e.preventDefault(); // Prevent label click
            e.stopPropagation(); // Stop event from bubbling up
            showNextPhoto();
        });


        // --- Limit Checking Logic (Refactored for single pass) ---
        function checkTradeLimits() {
            let overallInitialBalance = null, overallCurrentBalance = null, monthlyInitialBalance = null, monthlyCurrentBalance = null, dailyInitialBalance = null, dailyCurrentBalance = null;
            const now = new Date(); const currentMonthYearIdentifier = `${now.getFullYear()}-${now.getMonth()}`; const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0).getTime();

            executedPlansData.forEach(trade => {
                if (trade.outcome === 'Cancel') {
                    console.log("Skipping cancelled trade:", trade);
                    return;
                }
                const profitLossAmount = (trade.outcome === 'Take Profit') ? trade.nettTP : (trade.outcome === 'Stop Loss' ? trade.nettSL : 0);
                const tradeDate = new Date(trade.timestamp); const tradeTimestamp = tradeDate.getTime();
                const tradeMonthYearIdentifier = `${tradeDate.getFullYear()}-${tradeDate.getMonth()}`;

                // Overall balance calculation
                if (overallInitialBalance === null) { overallInitialBalance = trade.balance; overallCurrentBalance = trade.balance; }
                overallCurrentBalance += profitLossAmount;

                // Monthly balance calculation
                if (tradeMonthYearIdentifier === currentMonthYearIdentifier) {
                    if (monthlyInitialBalance === null) { monthlyInitialBalance = trade.balance; monthlyCurrentBalance = trade.balance; }
                    monthlyCurrentBalance += profitLossAmount;
                }
                // Daily balance calculation
                if (tradeTimestamp >= todayStart && tradeTimestamp <= now.getTime()) {
                    if (dailyInitialBalance === null) { dailyInitialBalance = trade.balance; dailyCurrentBalance = trade.balance; }
                    dailyCurrentBalance += profitLossAmount;
                }
            });
            
            const overallCumulativePercentageLoss = (overallInitialBalance !== null && overallInitialBalance !== 0) ? ((overallCurrentBalance - overallInitialBalance) / overallInitialBalance) * 100 : 0;
            const currentMonthPercentageLoss = (monthlyInitialBalance !== null && monthlyInitialBalance !== 0) ? ((monthlyCurrentBalance - monthlyInitialBalance) / monthlyInitialBalance) * 100 : 0;
            const currentDailyPercentageLoss = (dailyInitialBalance !== null && dailyInitialBalance !== 0) ? ((dailyCurrentBalance - dailyInitialBalance) / dailyInitialBalance) * 100 : 0;

            const lastOverallLossBreachMonth = localStorage.getItem('lastOverallLossBreachMonth');
            if (overallCumulativePercentageLoss <= OVERALL_MAX_LOSS_LIMIT) {
                if (lastOverallLossBreachMonth === currentMonthYearIdentifier) { limitNotificationMessage = `Anda sudah mencapai batas kerugian maksimal (-${Math.abs(OVERALL_MAX_LOSS_LIMIT)}%) secara keseluruhan. Input data akan diaktifkan kembali pada tanggal 1 bulan berikutnya.`; return false; }
                else { localStorage.setItem('lastOverallLossBreachMonth', currentMonthYearIdentifier); limitNotificationMessage = `Anda sudah mencapai batas kerugian maksimal (-${Math.abs(OVERALL_MAX_LOSS_LIMIT)}%) secara keseluruhan. Input data akan diaktifkan kembali pada tanggal 1 bulan berikutnya.`; return false; }
            } else { if (lastOverallLossBreachMonth === currentMonthYearIdentifier) localStorage.removeItem('lastOverallLossBreachMonth'); }
            if (currentMonthPercentageLoss <= MONTHLY_LOSS_LIMIT) { limitNotificationMessage = `Anda telah mencapai batas kerugian bulanan maksimum (-${Math.abs(MONTHLY_LOSS_LIMIT)}%). Input data akan diaktifkan kembali pada tanggal 1 bulan berikutnya.`; return false; }
            if (currentDailyPercentageLoss <= DAILY_LOSS_LIMIT) { limitNotificationMessage = `Anda telah mencapai batas kerugian harian (-${Math.abs(DAILY_LOSS_LIMIT)}%). Input data akan diaktifkan kembali pada hari berikutnya.`; return false; }
            limitNotificationMessage = ''; return true;
        }

        function displayLimitNotification(message) {
            const notificationDiv = document.getElementById('limitNotification');
            if (notificationDiv) { // Add null check here
                if (message) { notificationDiv.textContent = message; notificationDiv.classList.remove('hidden', 'error-message'); notificationDiv.classList.add('error-message'); }
                 else { notificationDiv.textContent = ''; notificationDiv.classList.add('hidden'); notificationDiv.classList.remove('error-message'); }
            }
        }

        

        

        // --- EVENT LISTENERS ---
        const addInputRowBtn = document.getElementById('addInputRowBtn');
        if (addInputRowBtn) { // Add null check here
            addInputRowBtn.addEventListener('click', () => {
                if (checkTradeLimits()) { addInputRow(); saveInputRowsToLocalStorage(); displayLimitNotification(''); }
                else { displayLimitNotification(limitNotificationMessage); }
            });
        }
        
        const calculateAllBtn = document.getElementById('calculateAllBtn');
        if (calculateAllBtn) { // Add null check here
            calculateAllBtn.addEventListener('click', () => { calculateAllRows(); saveDataToLocalStorage(); });
        }

        // --- LETAKKAN SEMUA KODE DI BAWAH INI SEBELUM EVENT LISTENER downloadNewMonthlySummaryBtn ---

const downloadDailySummaryBtn = document.getElementById('downloadNewDailySummaryBtn');
if (downloadDailySummaryBtn) {
    downloadDailySummaryBtn.addEventListener('click', () => {
        downloadDailySummaryAsExcel(`Ringkasan_Harian_Kumulatif_${new Date().toISOString().slice(0, 10)}.csv`);
    });
}

const downloadWeeklySummaryBtn = document.getElementById('downloadNewWeeklySummaryBtn');
if (downloadWeeklySummaryBtn) {
    downloadWeeklySummaryBtn.addEventListener('click', () => {
        downloadWeeklySummaryAsExcel(`Ringkasan_Mingguan_Kumulatif_${new Date().toISOString().slice(0, 10)}.csv`);
    });
}

const downloadYearlySummaryBtn = document.getElementById('downloadNewYearlySummaryBtn');
if (downloadYearlySummaryBtn) {
    downloadYearlySummaryBtn.addEventListener('click', () => {
        downloadYearlySummaryAsExcel(`Ringkasan_Tahunan_Kumulatif_${new Date().toISOString().slice(0, 10)}.csv`);
    });
}

// --- AKHIR DARI BLOK KODE BARU ---
        // --- PENAMBAHAN: Event listener untuk tombol unduh ringkasan bulanan ---
const downloadMonthlySummaryBtn = document.getElementById('downloadNewMonthlySummaryBtn');
if (downloadMonthlySummaryBtn) {
    downloadMonthlySummaryBtn.addEventListener('click', () => {
        downloadNewMonthlySummaryAsExcel(`Ringkasan_Bulanan_Kumulatif_${new Date().toISOString().slice(0, 10)}.csv`);
    });
}

     // --- DELETE AND EXPORT DATA FUNCTIONALITY ---
        if (deleteAndExportDataBtn) {
            deleteAndExportDataBtn.addEventListener('click', async () => {
                if (executedPlansData.length === 0) {
                    showMessageBox('Informasi', 'Tidak ada data untuk diunduh atau dihapus.', false);
                    return;
                }

                const confirmed = await showMessageBox(
                    'Unduh & Hapus Data?',
                    'Anda akan mengunduh semua data trading yang telah selesai, lalu menghapusnya secara permanen. Lanjutkan?',
                    true
                );

                if (!confirmed) {
                    showMessageBox('Dibatalkan', 'Proses dibatalkan.', false);
                    return;
                }

                // --- Langkah 1: Siapkan dan Unduh Data ---
                try {
                    // Menggunakan fungsi downloadAsExcel yang sudah ada dan header yang benar
                    const headers = ["Status", "Aset", "Trade", "BalanceAkun", "WaktuMasuk", "OpenPrice", "SLPrice", "TPPrice", "PendingPipsPoints", "SLPipsPoints", "TPPipsPoints", "RRPips", "R:R %", "LotUnits", "NettSL", "NettTP", "Catatan", "Hasil", "WaktuKeluar"];
                    const dataToExport = executedPlansData.map(plan => preparePlanForExport(plan, 'Selesai'));
                    downloadAsExcel(`Rencana_Trading_Selesai_${new Date().toISOString().slice(0, 10)}.csv`, dataToExport, headers);
                } catch (error) {
                    console.error("Error during data export:", error);
                    showMessageBox('Gagal Mengunduh', 'Terjadi kesalahan saat menyiapkan data untuk diunduh. Proses penghapusan dibatalkan.', false);
                    return; // Batalkan proses jika unduhan gagal
                }

                // --- Langkah 2: Hapus Data Setelah Unduhan Dimulai ---
                try {
                    // Hapus dari Firestore
                    if (db && userId !== 'anonymous') {
                        await deleteAllExecutedPlans(userId);
                    }
                    
                    // Hapus dari state lokal dan localStorage
                    executedPlansData = [];
                    localStorage.removeItem('lastOverallLossBreachMonth');
                    saveDataToLocalStorage();

                    // Render ulang semua komponen yang terpengaruh
                    renderExecutedPlans();
                    calculateSummaryStatistics();
                    updateRiskRewardStatistics();
                    calculateAndRenderDailySummary();
                    calculateAndRenderWeeklySummary();
                    calculateAndRenderNewMonthlySummary();
                    calculateAndRenderYearlySummary();

                    // Reset semua grafik
                    for (const sectionId in chartSections) {
                        const chartInfo = chartSections[sectionId];
                        if (chartInfo.chartInstance && chartInfo.chartInstance()) {
                            chartInfo.chartInstance().destroy();
                            chartInfo.setInstance(null);
                            chartInfo.hasRendered = false;
                        }
                    }

                    checkTradeLimits();
                    displayLimitNotification(limitNotificationMessage);
                    
                    showMessageBox('Berhasil', 'Data telah diunduh dan berhasil dihapus.', false);
                } catch (error) {
                    console.error("Error during data deletion:", error);
                    showMessageBox('Gagal Menghapus', 'Data berhasil diunduh, tetapi terjadi kesalahan saat menghapus data dari aplikasi.', false);
                    return;
                }
            });
        }   
        
        

        // --- UPLOAD DATA FUNCTIONALITY ---
        const hiddenFileInput = document.createElement('input');
hiddenFileInput.type = 'file';
hiddenFileInput.accept = '.csv';
hiddenFileInput.style.display = 'none';
document.body.appendChild(hiddenFileInput);

if (uploadDataBtn) {
            uploadDataBtn.addEventListener('click', async () => {
                // PERBAIKAN: Mengubah pesan konfirmasi dari "menimpa" menjadi "menambahkan"
                const confirmed = await showMessageBox(
                    'Unggah & Gabungkan Data?', 
                    'Mengunggah file akan MENAMBAHKAN data baru ke data yang sudah ada. Data lama tidak akan dihapus. Lanjutkan?', 
                    true
                );
                if (confirmed) {
                    hiddenFileInput.click();
                }
            });
        }

hiddenFileInput.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const parsedData = parseAllPlansFromCSV(e.target.result);
                await importAllPlans(parsedData);
                showMessageBox('Berhasil', 'Semua data trading berhasil diimpor.', false);
            } catch (error) {
                console.error('Error parsing or importing CSV:', error);
                showMessageBox('Gagal Unggah', 'Terjadi kesalahan. Pastikan format file CSV Anda benar dan sesuai dengan template unduhan.', false);
            } finally {
                hiddenFileInput.value = ''; // Reset input file
            }
        };
        reader.readAsText(file);
    }
});

    /**
         * Mem-parsing string CSV menjadi array objek plan yang terstruktur.
         * @param {string} csvString - Konten mentah dari file CSV.
         * @returns {Array<Object>} Array berisi objek-objek plan.
         */
        function parseAllPlansFromCSV(csvString) {
            const lines = csvString.trim().split('\n');
            if (lines.length < 2) return [];

            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
            const dataRows = lines.slice(1);

            const headerMap = {
                'Status': 'status', 'Aset': 'symbol', 'Trade': 'tradeType',
                'BalanceAkun': { key: 'balance', type: 'float' },
                'WaktuMasuk': { key: 'entryTime', type: 'date' },
                'OpenPrice': { key: 'openPrice', type: 'float' },
                'SLPrice': { key: 'slPrice', type: 'float' },
                'TPPrice': { key: 'tpPrice', type: 'float' },
                'PendingPipsPoints': { key: 'pendingPips', type: 'float', clean: val => parseFloat(val) / 10 },
                'SLPipsPoints': { key: 'slPips', type: 'float', clean: val => parseFloat(val) / 10 },
                'TPPipsPoints': { key: 'tpPips', type: 'float', clean: val => parseFloat(val) / 10 },
                'RRPips': { key: 'rrPips', type: 'float', clean: val => parseFloat(String(val).replace('1:', '')) },
                'R:R %': {
                    key: 'rrPercentage',
                    clean: val => {
                        if (typeof val !== 'string' || val === 'N/A') return { sl: 0, tp: 0 };
                        const numbers = val.match(/-?[\d,.]+/g);
                        if (numbers && numbers.length >= 2) {
                            const sl = parseFloat(numbers[0].replace(',', '.'));
                            const tp = parseFloat(numbers[1].replace(',', '.'));
                            if (!isNaN(sl) && !isNaN(tp)) return { sl: Math.abs(sl), tp: tp };
                        }
                        return { sl: 0, tp: 0 };
                    }
                },
                'LotUnits': { key: 'lotSize', type: 'float' },
                'NettSL': { key: 'nettSL', type: 'float' },
                'NettTP': { key: 'nettTP', type: 'float' },
                'Catatan': 'note', 'Hasil': 'outcome',
                'WaktuKeluar': { key: 'timestamp', type: 'date' }
            };

            const unquoteCsvField = (field) => {
                if (typeof field !== 'string') return field;
                const trimmedField = field.trim();
                if (trimmedField.startsWith('"') && trimmedField.endsWith('"')) {
                    return trimmedField.substring(1, trimmedField.length - 1).replace(/""/g, '"');
                }
                return trimmedField;
            };

            return dataRows.map(row => {
                const values = row.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(unquoteCsvField);
                const newPlan = {};
                headers.forEach((header, index) => {
                    const map = headerMap[header];
                    let value = values[index];
                    if (map) {
                        if (typeof map === 'string') {
                            newPlan[map] = value;
                        } else {
                            if (map.clean) value = map.clean(value);
                            else if (map.type === 'float') value = parseFloat(value);
                            else if (map.type === 'date') {
                                // --- PERBAIKAN DI SINI ---
                                const date = parseDateRobust(value); // Gunakan parser baru yang andal
                                value = date ? date.toISOString() : null; // Simpan sebagai ISO jika valid
                            }
                            newPlan[map.key] = value;
                        }
                    }
                });

                newPlan.assetData = getAssetData(newPlan.symbol);
                newPlan.rowId = `imported-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                return newPlan;
            }).filter(plan => plan.symbol && plan.status);
        }
   /**
         * Mengimpor semua data yang sudah di-parsing, MENGGABUNGKANNYA dengan data yang ada.
         * @param {Array<Object>} parsedData - Data yang sudah di-parsing dari CSV.
         */
        async function importAllPlans(parsedData) {
            // Pisahkan data yang baru diunggah berdasarkan statusnya
            const newCalculated = parsedData.filter(p => p.status === 'Baru');
            const newRunning = parsedData.filter(p => p.status === 'Aktif');
            const newExecuted = parsedData.filter(p => p.status === 'Selesai');

            // Cek apakah terhubung ke database
            if (db && userId !== 'anonymous') {
                try {
                    // Simpan data baru ke Firestore
                    const savePromises = [
                        ...newCalculated.map(p => saveCalculatedPlan(userId, p)),
                        ...newRunning.map(p => saveRunningPlan(userId, p)),
                        ...newExecuted.map(p => saveExecutedPlan(userId, p))
                    ];
                    await Promise.all(savePromises);
                    console.log("Data baru dari file telah disimpan ke Firestore.");
                    
                    // PERBAIKAN UTAMA: Panggil pembaruan UI secara manual dan langsung
                    // Ini memastikan tampilan diperbarui seketika setelah unggahan berhasil,
                    // tidak peduli seberapa cepat listener database merespons.
                    updateAllDataAndRenderUI(newCalculated, newRunning, newExecuted);

                } catch (error) {
                    console.error("Gagal menyimpan data yang diunggah ke Firestore:", error);
                    showMessageBox('Gagal Menyimpan', 'Terjadi kesalahan saat menyimpan data baru ke database.', false);
                }
            } else {
                // Untuk pengguna anonim atau jika database tidak terhubung,
                // langsung panggil fungsi pembaruan UI.
                updateAllDataAndRenderUI(newCalculated, newRunning, newExecuted);
            }
        }

    // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU DI BAWAH INI ---
    function calculateSummaryStatistics() {
        console.log("Calculating comprehensive summary statistics...");

        const relevantTrades = executedPlansData
            .filter(trade => trade.outcome === 'Take Profit' || trade.outcome === 'Stop Loss')
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        const elements = {
            totalSettledTrades: document.getElementById('totalSettledTradesSummary'),
            probability: document.getElementById('probabilitySummary'),
            totalPips: document.getElementById('totalPipsSummary'),
            avgPercentagePerTrade: document.getElementById('avgPercentagePerTradeSummary'),
            dailyPercentage: document.getElementById('dailyPercentageSummary'),
            monthlyPercentage: document.getElementById('monthlyPercentageSummary'),
            yearlyPercentage: document.getElementById('yearlyPercentageSummary'),
            overallPercentage: document.getElementById('overallPercentageSummary'),
            finalBalance: document.getElementById('finalBalanceSummary'),
            joinTime: document.getElementById('joinTimeSummary'),
            balanceDrawdown: document.getElementById('balanceDrawdownSummary'),
            balanceDrawdownPeriod: document.getElementById('balanceDrawdownSummaryPeriod'),
            overallMaxDrawdownPercentage: document.getElementById('overallMaxDrawdownPercentage'),
            overallMaxDrawdownPercentagePeriod: document.getElementById('overallMaxDrawdownPercentagePeriod')
        };

        if (relevantTrades.length === 0) {
            Object.values(elements).forEach(el => {
                if (el) {
                    if (el.id.includes('Period')) el.textContent = 'Periode: N/A';
                    else {
                        el.textContent = 'N/A';
                        el.classList.remove('negative-summary-value');
                    }
                }
            });
            // PERBAIKAN: Kembalikan objek kosong jika tidak ada data
            return {}; 
        }

        let totalPips = 0;
        const initialBalance = relevantTrades[0].balance;
        let finalBalanceValue = initialBalance;
        const firstTradeDate = new Date(relevantTrades[0].timestamp);
        let totalTakeProfitTrades = 0;
        
        let sumOfPercentageChanges = 0;
        let currentBalanceForAvg = initialBalance;

        const dailyStats = {}, monthlyStats = {}, yearlyStats = {};

        let peakBalance = initialBalance;
        let peakDate = firstTradeDate;
        let maxDrawdownPercentage = 0;
        let maxDrawdownAmount = 0;
        let maxDrawdownStartDate = null;
        let maxDrawdownEndDate = null;

        relevantTrades.forEach(trade => {
            const profitLossAmount = (trade.outcome === 'Take Profit') ? trade.nettTP : trade.nettSL;
            const pointsForTrade = (trade.outcome === 'Take Profit') ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;
            
            finalBalanceValue += profitLossAmount;
            totalPips += pointsForTrade;
            if (trade.outcome === 'Take Profit') totalTakeProfitTrades++;

            const percentageChangeForTrade = (currentBalanceForAvg > 0) ? (profitLossAmount / currentBalanceForAvg) * 100 : 0;
            sumOfPercentageChanges += percentageChangeForTrade;
            currentBalanceForAvg += profitLossAmount;

            const tradeDate = new Date(trade.timestamp);
            const dayKey = tradeDate.toISOString().split('T')[0];
            const monthKey = `${tradeDate.getFullYear()}-${tradeDate.getMonth()}`;
            const yearKey = `${tradeDate.getFullYear()}`;

            if (!dailyStats[dayKey]) { dailyStats[dayKey] = { pnl: 0, startBalance: 0, isNewDay: true }; }
            if (!monthlyStats[monthKey]) { monthlyStats[monthKey] = { pnl: 0, startBalance: 0, isNewMonth: true }; }
            if (!yearlyStats[yearKey]) { yearlyStats[yearKey] = { pnl: 0, startBalance: 0, isNewYear: true }; }
            
            if (dailyStats[dayKey].isNewDay) { dailyStats[dayKey].startBalance = currentBalanceForAvg - profitLossAmount; dailyStats[dayKey].isNewDay = false; }
            if (monthlyStats[monthKey].isNewMonth) { monthlyStats[monthKey].startBalance = currentBalanceForAvg - profitLossAmount; monthlyStats[monthKey].isNewMonth = false; }
            if (yearlyStats[yearKey].isNewYear) { yearlyStats[yearKey].startBalance = currentBalanceForAvg - profitLossAmount; yearlyStats[yearKey].isNewYear = false; }

            dailyStats[dayKey].pnl += profitLossAmount;
            monthlyStats[monthKey].pnl += profitLossAmount;
            yearlyStats[yearKey].pnl += profitLossAmount;

            if (finalBalanceValue > peakBalance) {
                peakBalance = finalBalanceValue;
                peakDate = tradeDate;
            } else {
                const currentDrawdown = ((peakBalance - finalBalanceValue) / peakBalance) * 100;
                if (currentDrawdown > maxDrawdownPercentage) {
                    maxDrawdownPercentage = currentDrawdown;
                    maxDrawdownAmount = peakBalance - finalBalanceValue;
                    maxDrawdownStartDate = peakDate;
                    maxDrawdownEndDate = tradeDate;
                }
            }
        });

        const totalSettledTrades = relevantTrades.length;
        const probability = (totalSettledTrades > 0) ? (totalTakeProfitTrades / totalSettledTrades) * 100 : 0;
        const overallPercentageChange = (initialBalance > 0) ? ((finalBalanceValue - initialBalance) / initialBalance) * 100 : 0;
        const avgPercentagePerTrade = totalSettledTrades > 0 ? sumOfPercentageChanges / totalSettledTrades : 0;
        const dailyPercentageChanges = Object.values(dailyStats).map(day => (day.startBalance > 0 ? (day.pnl / day.startBalance) * 100 : 0));
        const avgDailyPercentage = dailyPercentageChanges.length > 0 ? dailyPercentageChanges.reduce((a, b) => a + b, 0) / dailyPercentageChanges.length : 0;
        const monthlyPercentageChanges = Object.values(monthlyStats).map(month => (month.startBalance > 0 ? (month.pnl / month.startBalance) * 100 : 0));
        const avgMonthlyPercentage = monthlyPercentageChanges.length > 0 ? monthlyPercentageChanges.reduce((a, b) => a + b, 0) / monthlyPercentageChanges.length : 0;
        const yearlyPercentageChanges = Object.values(yearlyStats).map(year => (year.startBalance > 0 ? (year.pnl / year.startBalance) * 100 : 0));
        const avgYearlyPercentage = yearlyPercentageChanges.length > 0 ? yearlyPercentageChanges.reduce((a, b) => a + b, 0) / yearlyPercentageChanges.length : 0;
        const drawdownDurationMs = (maxDrawdownStartDate && maxDrawdownEndDate) ? maxDrawdownEndDate.getTime() - maxDrawdownStartDate.getTime() : 0;

        const updateElement = (el, value, isPercent = false, isCurrency = false) => {
            if (!el) return;
            let displayValue = 'N/A';
            if (typeof value === 'number' && !isNaN(value)) {
                displayValue = isCurrency ? formatCurrency(value, 'USD') : formatNumber(value, 2);
                if (isPercent) displayValue += '%';
            }
            el.textContent = displayValue;
            el.classList.toggle('negative-summary-value', value < 0);
        };

        if (elements.totalSettledTrades) elements.totalSettledTrades.textContent = totalSettledTrades;
        updateElement(elements.probability, probability, true);
        updateElement(elements.totalPips, totalPips);
        updateElement(elements.avgPercentagePerTrade, avgPercentagePerTrade, true);
        updateElement(elements.dailyPercentage, avgDailyPercentage, true);
        updateElement(elements.monthlyPercentage, avgMonthlyPercentage, true);
        updateElement(elements.yearlyPercentage, avgYearlyPercentage, true);
        updateElement(elements.overallPercentage, overallPercentageChange, true);
        updateElement(elements.finalBalance, finalBalanceValue, false, true);
        if (elements.joinTime) elements.joinTime.textContent = firstTradeDate.toLocaleDateString('id-ID', { year: 'numeric', month: 'long', day: 'numeric' });
        if (elements.balanceDrawdown) { elements.balanceDrawdown.textContent = formatCurrency(-maxDrawdownAmount, 'USD'); elements.balanceDrawdown.classList.add('negative-summary-value'); }
        if (elements.balanceDrawdownPeriod) elements.balanceDrawdownPeriod.textContent = `Periode: ${formatDuration(drawdownDurationMs)}`;
        if (elements.overallMaxDrawdownPercentage) { elements.overallMaxDrawdownPercentage.textContent = `${formatNumber(-maxDrawdownPercentage, 2)}%`; elements.overallMaxDrawdownPercentage.classList.add('negative-summary-value'); }
        if (elements.overallMaxDrawdownPercentagePeriod) elements.overallMaxDrawdownPercentagePeriod.textContent = `Periode: ${formatDuration(drawdownDurationMs)}`;

        // --- PERBAIKAN: Tambahkan blok 'return' di akhir fungsi ---
        return {
            totalSettledTrades,
            probability: formatNumber(probability, 2),
            totalPips: formatNumber(totalPips, 0),
            finalBalance: finalBalanceValue,
            overallPercentage: formatNumber(overallPercentageChange, 2),
            joinTime: firstTradeDate.toLocaleDateString('id-ID', { year: 'numeric', month: 'long', day: 'numeric' }),
            balanceDrawdown: -maxDrawdownAmount,
            balanceDrawdownPeriod: formatDuration(drawdownDurationMs),
            overallMaxDrawdownPercentage: formatNumber(-maxDrawdownPercentage, 2),
            overallMaxDrawdownPercentagePeriod: formatDuration(drawdownDurationMs)
        };
    }



// --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU DI BAWAH INI ---
    function updateRiskRewardStatistics() {
        console.log("Updating risk and reward statistics with period info...");
        const relevantTrades = executedPlansData.filter(trade => trade.outcome === 'Take Profit' || trade.outcome === 'Stop Loss');
        
        const elements = {
            avgRiskReward: document.getElementById('avgRiskReward'),
            avgSignalSettledMonth: document.getElementById('avgSignalSettledMonth'),
            avgHoldingPeriod: document.getElementById('avgHoldingPeriod'),
            avgTpPips: document.getElementById('avgTpPips'),
            avgSlPips: document.getElementById('avgSlPips'),
            consecutiveProfit: document.getElementById('consecutiveProfit'),
            consecutiveProfitPeriod: document.getElementById('consecutiveProfitPeriod'),
            consecutiveLoss: document.getElementById('consecutiveLoss'),
            consecutiveLossPeriod: document.getElementById('consecutiveLossPeriod'),
            averagePips: document.getElementById('averagePips'),
            grossProfit: document.getElementById('grossProfit'),
            grossLoss: document.getElementById('grossLoss'),
            avgSignalSettledWeek: document.getElementById('avgSignalSettledWeek'),
            maxHoldingPeriod: document.getElementById('maxHoldingPeriod'),
            maxTpPips: document.getElementById('maxTpPips'),
            maxSlPips: document.getElementById('maxSlPips'),
            maxBalanceDrawdown: document.getElementById('maxBalanceDrawdown'),
            maxBalanceDrawdownPeriod: document.getElementById('maxBalanceDrawdownPeriod'),
            monthlyBalanceDrawdown: document.getElementById('monthlyBalanceDrawdown'),
            monthlyBalanceDrawdownPeriod: document.getElementById('monthlyBalanceDrawdownPeriod'),
            monthlyMaxDrawdownPercentage: document.getElementById('monthlyMaxDrawdownPercentage'),
            monthlyMaxDrawdownPercentagePeriod: document.getElementById('monthlyMaxDrawdownPercentagePeriod')
        };

        if (relevantTrades.length === 0) {
            Object.values(elements).forEach(el => {
                if (el) {
                    if (el.id.includes('Period')) el.textContent = 'Periode: N/A';
                    else if (el.id === 'avgRiskReward') el.innerHTML = '1 : <span class="text-black">N/A</span>';
                    else el.innerHTML = '<span class="text-black">N/A</span>';
                }
            });
            // PERBAIKAN: Kembalikan objek kosong jika tidak ada data
            return {};
        }

        let totalTpPips = 0, countTpTrades = 0, totalSlPipsAbsolute = 0, countSlTrades = 0, totalPips = 0;
        let grossProfit = 0, grossLoss = 0, totalHoldingPeriodMs = 0, maxHoldingPeriodMs = 0;
        let maxTpPips = -Infinity, maxSlPips = Infinity;
        let currentProfitStreak = 0, maxProfitStreak = 0, profitStreakStartDate = null, maxProfitStreakStartDate = null, maxProfitStreakEndDate = null;
        let currentLossStreak = 0, maxLossStreak = 0, lossStreakStartDate = null, maxLossStreakStartDate = null, maxLossStreakEndDate = null;
        const monthlyTradeCounts = {}, weeklyTradeCounts = {};
        const monthlyDrawdownData = {};

        relevantTrades.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        relevantTrades.forEach(trade => {
            const tradeDate = new Date(trade.timestamp);
            const profitLossAmount = (trade.outcome === 'Take Profit') ? trade.nettTP : trade.nettSL;
            const holdingDuration = trade.entryTime ? tradeDate.getTime() - new Date(trade.entryTime).getTime() : 0;
            totalHoldingPeriodMs += holdingDuration;
            if (holdingDuration > maxHoldingPeriodMs) maxHoldingPeriodMs = holdingDuration;

            if (trade.outcome === 'Take Profit') {
                const pips = getVisualPoints(trade.tpPips, trade.symbol, true).forCalc;
                totalTpPips += pips; countTpTrades++; totalPips += pips; grossProfit += trade.nettTP;
                if (pips > maxTpPips) maxTpPips = pips;
                currentProfitStreak++;
                if (profitStreakStartDate === null) profitStreakStartDate = tradeDate;
                if (currentProfitStreak > maxProfitStreak) { maxProfitStreak = currentProfitStreak; maxProfitStreakStartDate = profitStreakStartDate; maxProfitStreakEndDate = tradeDate; }
                currentLossStreak = 0; lossStreakStartDate = null;
            } else {
                const pips = Math.abs(getVisualPoints(trade.slPips, trade.symbol, true).forCalc);
                totalSlPipsAbsolute += pips; countSlTrades++; totalPips -= pips; grossLoss += trade.nettSL;
                if (-pips < maxSlPips) maxSlPips = -pips;
                currentLossStreak++;
                if (lossStreakStartDate === null) lossStreakStartDate = tradeDate;
                if (currentLossStreak > maxLossStreak) { maxLossStreak = currentLossStreak; maxLossStreakStartDate = lossStreakStartDate; maxLossStreakEndDate = tradeDate; }
                currentProfitStreak = 0; profitStreakStartDate = null;
            }

            const monthYear = `${tradeDate.getFullYear()}-${tradeDate.getMonth()}`;
            if (!monthlyDrawdownData[monthYear]) {
                monthlyDrawdownData[monthYear] = { initialBalance: trade.balance, currentBalance: trade.balance, peakBalance: trade.balance, maxDrawdownPercentage: 0, maxDrawdownAmount: 0, peakDate: tradeDate, troughDate: tradeDate };
            }
            const monthData = monthlyDrawdownData[monthYear];
            monthData.currentBalance += profitLossAmount;
            if (monthData.currentBalance > monthData.peakBalance) {
                monthData.peakBalance = monthData.currentBalance;
                monthData.peakDate = tradeDate;
            } else {
                const currentMonthDD = ((monthData.peakBalance - monthData.currentBalance) / monthData.peakBalance) * 100;
                if (currentMonthDD > monthData.maxDrawdownPercentage) {
                    monthData.maxDrawdownPercentage = currentMonthDD;
                    monthData.maxDrawdownAmount = monthData.peakBalance - monthData.currentBalance;
                    monthData.troughDate = tradeDate;
                }
            }
            
            const monthKey = `${tradeDate.getFullYear()}-${(tradeDate.getMonth() + 1).toString().padStart(2, '0')}`;
            monthlyTradeCounts[monthKey] = (monthlyTradeCounts[monthKey] || 0) + 1;
            const weekNumber = Math.ceil(( (tradeDate - new Date(tradeDate.getFullYear(), 0, 1)) / 86400000 + new Date(tradeDate.getFullYear(), 0, 1).getDay() + 1) / 7 );
            weeklyTradeCounts[`${tradeDate.getFullYear()}-${String(weekNumber).padStart(2, '0')}`] = (weeklyTradeCounts[`${tradeDate.getFullYear()}-${String(weekNumber).padStart(2, '0')}`] || 0) + 1;
        });

        const avgTpPipsVal = countTpTrades > 0 ? totalTpPips / countTpTrades : 0;
        const avgSlPipsVal = countSlTrades > 0 ? totalSlPipsAbsolute / countSlTrades : 0;
        const avgRiskRewardVal = avgSlPipsVal > 0 ? avgTpPipsVal / avgSlPipsVal : 0;
        const avgPipsVal = relevantTrades.length > 0 ? totalPips / relevantTrades.length : 0;
        const avgHoldingPeriodMsVal = relevantTrades.length > 0 ? totalHoldingPeriodMs / relevantTrades.length : 0;
        const avgSignalSettledMonthVal = Object.keys(monthlyTradeCounts).length > 0 ? Object.values(monthlyTradeCounts).reduce((s, c) => s + c, 0) / Object.keys(monthlyTradeCounts).length : 0;
        const avgSignalSettledWeekVal = Object.keys(weeklyTradeCounts).length > 0 ? Object.values(weeklyTradeCounts).reduce((s, c) => s + c, 0) / Object.keys(weeklyTradeCounts).length : 0;
        
        let overallMaxMonthlyDrawdownPercentage = 0, monthlyBalanceDrawdownAmount = 0, monthlyDDPeakDate = null, monthlyDDTroughDate = null;
        for (const key in monthlyDrawdownData) {
            if (monthlyDrawdownData[key].maxDrawdownPercentage > overallMaxMonthlyDrawdownPercentage) {
                overallMaxMonthlyDrawdownPercentage = monthlyDrawdownData[key].maxDrawdownPercentage;
                monthlyBalanceDrawdownAmount = monthlyDrawdownData[key].maxDrawdownAmount;
                monthlyDDPeakDate = monthlyDrawdownData[key].peakDate;
                monthlyDDTroughDate = monthlyDrawdownData[key].troughDate;
            }
        }
        const monthlyDrawdownDurationMs = (monthlyDDPeakDate && monthlyDDTroughDate) ? monthlyDDTroughDate.getTime() - monthlyDDPeakDate.getTime() : 0;

        if (elements.avgRiskReward) elements.avgRiskReward.innerHTML = `1 : ${getColoredValueHtml(avgRiskRewardVal, false, 1)}`;
        if (elements.avgSignalSettledMonth) elements.avgSignalSettledMonth.innerHTML = getColoredValueHtml(avgSignalSettledMonthVal, false, 0);
        if (elements.avgHoldingPeriod) elements.avgHoldingPeriod.innerHTML = formatDuration(avgHoldingPeriodMsVal);
        if (elements.avgTpPips) elements.avgTpPips.innerHTML = getColoredValueHtml(avgTpPipsVal, false, 1);
        if (elements.avgSlPips) elements.avgSlPips.innerHTML = getColoredValueHtml(avgSlPipsVal, false, 1);
        if (elements.consecutiveProfit) elements.consecutiveProfit.innerHTML = getColoredValueHtml(maxProfitStreak, false, 0);
        if (elements.consecutiveProfitPeriod) elements.consecutiveProfitPeriod.textContent = `Periode: ${formatDuration(maxProfitStreakEndDate && maxProfitStreakStartDate ? maxProfitStreakEndDate - maxProfitStreakStartDate : 0)}`;
        if (elements.consecutiveLoss) elements.consecutiveLoss.innerHTML = getColoredValueHtml(-maxLossStreak, false, 0);
        if (elements.consecutiveLossPeriod) elements.consecutiveLossPeriod.textContent = `Periode: ${formatDuration(maxLossStreakEndDate && maxLossStreakStartDate ? maxLossStreakEndDate - maxLossStreakStartDate : 0)}`;
        if (elements.averagePips) elements.averagePips.innerHTML = getColoredValueHtml(avgPipsVal, false, 1);
        if (elements.grossProfit) elements.grossProfit.innerHTML = getColoredValueHtml(grossProfit, true);
        if (elements.grossLoss) elements.grossLoss.innerHTML = getColoredValueHtml(grossLoss, true);
        if (elements.avgSignalSettledWeek) elements.avgSignalSettledWeek.innerHTML = getColoredValueHtml(avgSignalSettledWeekVal, false, 0);
        if (elements.maxHoldingPeriod) elements.maxHoldingPeriod.innerHTML = formatDuration(maxHoldingPeriodMs);
        if (elements.maxTpPips) elements.maxTpPips.innerHTML = getColoredValueHtml(maxTpPips === -Infinity ? 'N/A' : maxTpPips, false, 1);
        if (elements.maxSlPips) elements.maxSlPips.innerHTML = getColoredValueHtml(maxSlPips === Infinity ? 'N/A' : maxSlPips, false, 1);
        const overallDDAmount = parseFloat(document.getElementById('balanceDrawdownSummary').textContent.replace(/[$,]/g, '')) || 0;
        const overallDDPeriod = document.getElementById('balanceDrawdownSummaryPeriod').textContent;
        if (elements.maxBalanceDrawdown) elements.maxBalanceDrawdown.innerHTML = getColoredValueHtml(overallDDAmount, true);
        if (elements.maxBalanceDrawdownPeriod) elements.maxBalanceDrawdownPeriod.textContent = overallDDPeriod;
        if (elements.monthlyBalanceDrawdown) elements.monthlyBalanceDrawdown.innerHTML = getColoredValueHtml(-monthlyBalanceDrawdownAmount, true);
        if (elements.monthlyBalanceDrawdownPeriod) elements.monthlyBalanceDrawdownPeriod.textContent = `Periode: ${formatDuration(monthlyDrawdownDurationMs)}`;
        if (elements.monthlyMaxDrawdownPercentage) { const value = -overallMaxMonthlyDrawdownPercentage; let html = getColoredValueHtml(value, false, 2); if (!html.includes('N/A')) { html = html.replace('</span>', '%</span>'); } elements.monthlyMaxDrawdownPercentage.innerHTML = html; }
        if (elements.monthlyMaxDrawdownPercentagePeriod) elements.monthlyMaxDrawdownPercentagePeriod.textContent = `Periode: ${formatDuration(monthlyDrawdownDurationMs)}`;

        // --- PERBAIKAN: Tambahkan blok 'return' di akhir fungsi ---
        return {
            avgRiskRewardVal,
            avgSignalSettledMonthVal,
            avgHoldingPeriodMsVal,
            avgTpPipsVal,
            avgSlPipsVal,
            maxProfitStreak,
            maxLossStreak,
            avgPipsVal,
            grossProfit,
            grossLoss
        };
    }

        function initializeAppFromLocalStorage() {
            console.log("Inisialisasi aplikasi dari localStorage...");

            // --- PERBAIKAN DIMULAI DI SINI ---
            // 1. Muat semua data dari localStorage ke dalam variabel global
            loadDataFromLocalStorage(); // Memuat data trading
            loadPhotosFromLocalStorage(); // MEMUAT DATA FOTO (YANG HILANG)
            loadSimulatorData(); // Memuat data simulator
            const hasInputRows = loadInputRowsFromLocalStorage(); // Memuat baris input

            // Jika tidak ada baris input yang tersimpan, tambahkan satu baris default
            if (!hasInputRows) {
                addInputRow();
            }
            
            // 2. Render ulang semua komponen dari data yang sudah dimuat
            renderPhotoGallery(); // MERENDER GALERI FOTO (YANG HILANG)
            renderCalculatedPlans();
            renderRunningPlans();
            renderExecutedPlans();

            // 3. Hitung ulang dan tampilkan semua statistik dan ringkasan
            calculateSummaryStatistics();
            updateRiskRewardStatistics();
            calculateAndRenderDailySummary();
            calculateAndRenderWeeklySummary();
            calculateAndRenderNewMonthlySummary();
            calculateAndRenderYearlySummary();

            // 4. Cek batas risiko dan tampilkan notifikasi jika perlu
            checkTradeLimits();
            displayLimitNotification(limitNotificationMessage);
            // --- AKHIR PERBAIKAN ---
        }

        const chartSections = {
            'overallSummaryStatisticsSection': { render: calculateSummaryStatistics, chartInstance: () => null, setInstance: () => {}, canvasId: null, loadingId: null, errorId: null, noDataId: null, hasRendered: false },
            'riskRewardStatisticsSection': { render: updateRiskRewardStatistics, chartInstance: () => null, setInstance: () => {}, canvasId: null, loadingId: null, errorId: null, noDataId: null, hasRendered: false },
            'assetSuccessStatisticsSection': { render: fetchAndRenderPieChart, chartInstance: () => assetPieChart, setInstance: (chart) => assetPieChart = chart, canvasId: 'assetSuccessPieChart', loadingId: 'pieChartLoading', errorId: 'pieChartError', noDataId: 'pieChartNoData', hasRendered: false },
             'dailyLineStatisticsSection': { render: fetchAndRenderDailyLineChart, chartInstance: () => dailyLineChart, setInstance: (chart) => dailyLineChart = chart, canvasId: 'dailyLineChart', loadingId: 'dailyLineChartLoading', errorId: 'dailyLineChartError', noDataId: 'dailyLineChartNoData', hasRendered: false },
            'monthlyBarStatisticsSection': { render: fetchAndRenderMonthlyBarChart, chartInstance: () => monthlyBarChart, setInstance: (chart) => monthlyBarChart = chart, canvasId: 'monthlyBarChart', loadingId: 'monthlyBarChartLoading', errorId: 'monthlyBarChartError', noDataId: 'monthlyBarChartNoData', hasRendered: false },
            'overallPercentageCumulativeStatisticsSection': { render: fetchAndRenderOverallPercentageCumulativeChart, chartInstance: () => overallPercentageCumulativeChart, setInstance: (chart) => overallPercentageCumulativeChart = chart, canvasId: 'overallPercentageCumulativeChart', loadingId: 'overallPercentageCumulativeChartLoading', errorId: 'overallPercentageCumulativeChartError', noDataId: 'overallPercentageCumulativeChartNoData', hasRendered: false },
            'overallBalanceCumulativeStatisticsSection': { render: fetchAndRenderOverallBalanceCumulativeChart, chartInstance: () => overallBalanceCumulativeChart, setInstance: (chart) => overallBalanceCumulativeChart = chart, canvasId: 'overallBalanceCumulativeChart', loadingId: 'overallBalanceCumulativeChartLoading', errorId: 'overallBalanceCumulativeChartError', noDataId: 'overallBalanceCumulativeChartNoData', hasRendered: false },
            'overallPipsCumulativeStatisticsSection': { render: fetchAndRenderOverallPipsCumulativeChart, chartInstance: () => overallPipsCumulativeChart, setInstance: (chart) => overallPipsCumulativeChart = chart, canvasId: 'overallPipsCumulativeChart', loadingId: 'overallPipsCumulativeChartLoading', errorId: 'overallPipsCumulativeChartError', noDataId: 'overallPipsCumulativeChartNoData', hasRendered: false },
            'combinedSummaryBarStatisticsSection': { render: fetchAndRenderCombinedBarChart, chartInstance: () => combinedBarChart, setInstance: (chart) => combinedBarChart = chart, canvasId: 'combinedSummaryBarChart', loadingId: 'combinedSummaryBarChartLoading', errorId: 'combinedSummaryBarChartError', noDataId: 'combinedSummaryBarChartNoData', hasRendered: false },
            'tradeFrequencyStatisticsSection': { render: fetchAndRenderTradeFrequencyChart, chartInstance: () => tradeFrequencyChart, setInstance: (chart) => tradeFrequencyChart = chart, canvasId: 'tradeFrequencyChart', loadingId: 'tradeFrequencyChartLoading', errorId: 'tradeFrequencyChartError', noDataId: 'tradeFrequencyChartNoData', hasRendered: false },
            'balanceFrequencyStatisticsSection': { render: fetchAndRenderBalanceFrequencyChart, chartInstance: () => balanceFrequencyChart, setInstance: (chart) => balanceFrequencyChart = chart, canvasId: 'balanceFrequencyChart', loadingId: 'balanceFrequencyChartLoading', errorId: 'balanceFrequencyChartError', noDataId: 'balanceFrequencyChartNoData', hasRendered: false },
        'percentageFrequencyStatisticsSection': { render: fetchAndRenderPercentageFrequencyChart, chartInstance: () => percentageFrequencyChart, setInstance: (chart) => percentageFrequencyChart = chart, canvasId: 'percentageFrequencyChart', loadingId: 'percentageFrequencyChartLoading', errorId: 'percentageFrequencyChartError', noDataId: 'percentageFrequencyChartNoData', hasRendered: false },
        'pipsFrequencyStatisticsSection': { render: fetchAndRenderPipsFrequencyChart, chartInstance: () => pipsFrequencyChart, setInstance: (chart) => pipsFrequencyChart = chart, canvasId: 'pipsFrequencyChart', loadingId: 'pipsFrequencyChartLoading', errorId: 'pipsFrequencyChartError', noDataId: 'pipsFrequencyChartNoData', hasRendered: false },
        'executionFrequencyStatisticsSection': { render: fetchAndRenderExecutionFrequencyChart, chartInstance: () => executionFrequencyChart, setInstance: (chart) => executionFrequencyChart = chart, canvasId: 'executionFrequencyChart', loadingId: 'executionFrequencyChartLoading', errorId: 'executionFrequencyChartError', noDataId: 'executionFrequencyChartNoData', hasRendered: false },
        'assetExecutionCountStatisticsSection': { render: fetchAndRenderAssetExecutionCountChart, chartInstance: () => assetExecutionCountChart, setInstance: (chart) => assetExecutionCountChart = chart, canvasId: 'assetExecutionCountChart', loadingId: 'assetExecutionCountChartLoading', errorId: 'assetExecutionCountChartError', noDataId: 'assetExecutionCountChartNoData', hasRendered: false },
        };
        

        // --- SCROLL ANIMATION LOGIC ---
        const animateOnScroll = () => {
            const sections = document.querySelectorAll('.scroll-animate-section');
            
            // Putuskan koneksi observer lama jika ada untuk menghindari duplikasi
            if (scrollObserver) {
                scrollObserver.disconnect();
            }

            scrollObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const sectionId = entry.target.id; const chartInfo = chartSections[sectionId];
                    if (entry.isIntersecting) {
                         entry.target.classList.add('scrolled-into-view');
                        if (chartInfo && !chartInfo.hasRendered && chartInfo.canvasId) { chartInfo.render(); chartInfo.hasRendered = true; }
                    } else {
                        // Jangan hapus kelas jika tidak ingin animasi berulang saat scroll ke atas
                        // entry.target.classList.remove('scrolled-into-view');
                        if (chartInfo && chartInfo.chartInstance && chartInfo.chartInstance()) { chartInfo.chartInstance().destroy(); chartInfo.setInstance(null); chartInfo.hasRendered = false; }
                    }
                });
            }, { root: null, rootMargin: '0px', threshold: 0.1 });
            sections.forEach(section => scrollObserver.observe(section));
        };

        // --- EVENT LISTENERS (REVISED & CONSOLIDATED) ---
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("DOM Content Loaded. Initializing app...");
            updateDateTime();
            setInterval(updateDateTime, 1000);

            // Initialize Firebase or fallback to localStorage
            if (Object.keys(firebaseConfig).length > 0 && typeof __firebase_config !== 'undefined' && __firebase_config !== '{}') {
                console.log("Firebase config found, initializing...");
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                storage = getStorage(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Authenticated with Firebase UID:", userId);
                        await loadProfilePictures(userId);
                        await loadCalculatedPlans(userId);
                        await loadRunningPlans(userId);
                        await loadExecutedPlans(userId);
                    } else {
                        try {
                            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                        } catch (error) {
                            console.error("Firebase authentication failed, falling back to localStorage.", error);
                            initializeAppFromLocalStorage();
                        }
                    }
                });
            } else {
                console.log("No Firebase config. Using localStorage.");
                initializeAppFromLocalStorage();
            }

            // Attach all button event listeners here to ensure functions are in scope
            const addInputRowBtn = document.getElementById('addInputRowBtn');
            if (addInputRowBtn) {
                addInputRowBtn.addEventListener('click', () => {
                    if (checkTradeLimits()) {
                        addInputRow();
                        saveInputRowsToLocalStorage();
                        displayLimitNotification('');
                    } else {
                        displayLimitNotification(limitNotificationMessage);
                    }
                });
            }

            const calculateAllBtn = document.getElementById('calculateAllBtn');
            if (calculateAllBtn) {
                calculateAllBtn.addEventListener('click', () => {
                    calculateAllRows();
                    saveDataToLocalStorage();
                });
            }
            
            // PDF Download Listener
            const downloadPdfBtn = document.getElementById('downloadAllPdfBtn');
            if (downloadPdfBtn) {
                downloadPdfBtn.addEventListener('click', () => {
                    downloadAllDataAsPdf(`Laporan_Trading_Lengkap_${new Date().toISOString().slice(0, 10)}.pdf`);
                });
            }

            // Other event listeners
            animateOnScroll();
            console.log("Application initialization complete.");
        });
        window.exportToCsv = exportToCsv;
        window.exportToPdf = exportToPdf;
    </script>
</body>
</html>